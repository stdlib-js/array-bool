{"version":3,"file":"index.mjs","sources":["../lib/from_iterator.js","../lib/main.js","../lib/from_array.js","../lib/from_iterator_map.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Boolean from '@stdlib/boolean-ctor';\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @returns {Array} output array\n*/\nfunction fromIterator( it ) {\n\tvar out;\n\tvar v;\n\n\tout = [];\n\twhile ( true ) {\n\t\tv = it.next();\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t\tout.push( Boolean( v.value ) );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default fromIterator;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this */\n\n'use strict';\n\n// MODULES //\n\nimport { isPrimitive as isNonNegativeInteger } from '@stdlib/assert-is-nonnegative-integer';\nimport isCollection from '@stdlib/assert-is-collection';\nimport isArrayBuffer from '@stdlib/assert-is-arraybuffer';\nimport isObject from '@stdlib/assert-is-object';\nimport isFunction from '@stdlib/assert-is-function';\nimport { isPrimitive as isBoolean } from '@stdlib/assert-is-boolean';\nimport { isPrimitive as isInteger } from '@stdlib/assert-is-integer';\nimport { isPrimitive as isString } from '@stdlib/assert-is-string';\nimport { primitives as isStringArray } from '@stdlib/assert-is-string-array';\nimport hasIteratorSymbolSupport from '@stdlib/assert-has-iterator-symbol-support';\nimport ITERATOR_SYMBOL from '@stdlib/symbol-iterator';\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport setReadOnlyAccessor from '@stdlib/utils-define-nonenumerable-read-only-accessor';\nimport Uint8Array from '@stdlib/array-uint8';\nimport Boolean from '@stdlib/boolean-ctor';\nimport getter from '@stdlib/array-base-getter';\nimport floor from '@stdlib/math-base-special-floor';\nimport accessorGetter from '@stdlib/array-base-accessor-getter';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport fromIterator from './from_iterator.js';\nimport fromIteratorMap from './from_iterator_map.js';\nimport fromArray from './from_array.js';\n\n\n// VARIABLES //\n\nvar BYTES_PER_ELEMENT = Uint8Array.BYTES_PER_ELEMENT;\nvar HAS_ITERATOR_SYMBOL = hasIteratorSymbolSupport();\n\n\n// FUNCTIONS //\n\n/**\n* Returns a boolean indicating if a value is a `BooleanArray`.\n*\n* @private\n* @param {*} value - value to test\n* @returns {boolean} boolean indicating if a value is a `BooleanArray`\n*/\nfunction isBooleanArray( value ) {\n\treturn (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\tvalue.constructor.name === 'BooleanArray' &&\n\t\tvalue.BYTES_PER_ELEMENT === BYTES_PER_ELEMENT\n\t);\n}\n\n/**\n* Returns a boolean indicating if a value is a boolean typed array constructor.\n*\n* @private\n* @param {*} value - value to test\n* @returns {boolean} boolean indicating if a value is a boolean typed array constructor\n*/\nfunction isBooleanArrayConstructor( value ) {\n\treturn ( value === BooleanArray);\n}\n\n\n// MAIN //\n\n/**\n* Boolean array constructor.\n*\n* @constructor\n* @param {(NonNegativeInteger|Collection|ArrayBuffer|Iterable)} [arg] - length, typed array, array-like object, buffer, or an iterable\n* @param {NonNegativeInteger} [byteOffset=0] - byte offset\n* @param {NonNegativeInteger} [length] - view length\n* @throws {TypeError} if provided only a single argument, must provide a valid argument\n* @throws {TypeError} byte offset must be a nonnegative integer\n* @throws {RangeError} must provide sufficient memory to accommodate byte offset and view length requirements\n* @returns {BooleanArray} boolean array\n*\n* @example\n* var arr = new BooleanArray();\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 0\n*\n* @example\n* var arr = new BooleanArray( 2 );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 2\n*\n* @example\n* var arr = new BooleanArray( [ true, false ] );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 2\n*\n* @example\n* import ArrayBuffer from '@stdlib/array-buffer';\n*\n* var buf = new ArrayBuffer( 16 );\n* var arr = new BooleanArray( buf );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 16\n*\n* @example\n* import ArrayBuffer from '@stdlib/array-buffer';\n*\n* var buf = new ArrayBuffer( 16 );\n* var arr = new BooleanArray( buf, 8 );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 8\n*\n* @example\n* import ArrayBuffer from '@stdlib/array-buffer';\n*\n* var buf = new ArrayBuffer( 32 );\n* var arr = new BooleanArray( buf, 8, 2 );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 2\n*/\nfunction BooleanArray() {\n\tvar byteOffset;\n\tvar nargs;\n\tvar buf;\n\tvar len;\n\tvar arg;\n\n\tnargs = arguments.length;\n\tif ( !(this instanceof BooleanArray) ) {\n\t\tif ( nargs === 0 ) {\n\t\t\treturn new BooleanArray();\n\t\t}\n\t\tif ( nargs === 1 ) {\n\t\t\treturn new BooleanArray( arguments[0] );\n\t\t}\n\t\tif ( nargs === 2 ) {\n\t\t\treturn new BooleanArray( arguments[0], arguments[1] );\n\t\t}\n\t\treturn new BooleanArray( arguments[0], arguments[1], arguments[2] );\n\t}\n\t// Create the underlying data buffer...\n\tif ( nargs === 0 ) {\n\t\tbuf = new Uint8Array( 0 ); // backward-compatibility\n\t} else if ( nargs === 1 ) {\n\t\targ = arguments[ 0 ];\n\t\tif ( isNonNegativeInteger( arg ) ) {\n\t\t\tbuf = new Uint8Array( arg );\n\t\t} else if ( isCollection( arg ) ) {\n\t\t\tbuf = fromArray( new Uint8Array( arg.length ), arg );\n\t\t} else if ( isArrayBuffer( arg ) ) {\n\t\t\tbuf = new Uint8Array( arg );\n\t\t} else if ( isObject( arg ) ) {\n\t\t\tif ( HAS_ITERATOR_SYMBOL === false ) {\n\t\t\t\tthrow new TypeError( format( 'null29', arg ) );\n\t\t\t}\n\t\t\tif ( !isFunction( arg[ ITERATOR_SYMBOL ] ) ) {\n\t\t\t\tthrow new TypeError( format( 'null2A', arg ) );\n\t\t\t}\n\t\t\tbuf = arg[ ITERATOR_SYMBOL ]();\n\t\t\tif ( !isFunction( buf.next ) ) {\n\t\t\t\tthrow new TypeError( format( 'null2A', arg ) );\n\t\t\t}\n\t\t\tbuf = new Uint8Array( fromIterator( buf ) );\n\t\t} else {\n\t\t\tthrow new TypeError( format( 'null2A', arg ) );\n\t\t}\n\t} else {\n\t\tbuf = arguments[ 0 ];\n\t\tif ( !isArrayBuffer( buf ) ) {\n\t\t\tthrow new TypeError( format( 'null2B', buf ) );\n\t\t}\n\t\tbyteOffset = arguments[ 1 ];\n\t\tif ( !isNonNegativeInteger( byteOffset ) ) {\n\t\t\tthrow new TypeError( format( 'null2C', byteOffset ) );\n\t\t}\n\t\tif ( nargs === 2 ) {\n\t\t\tbuf = new Uint8Array( buf, byteOffset );\n\t\t} else {\n\t\t\tlen = arguments[ 2 ];\n\t\t\tif ( !isNonNegativeInteger( len ) ) {\n\t\t\t\tthrow new TypeError( format( 'null2F', len ) );\n\t\t\t}\n\t\t\tif ( (len*BYTES_PER_ELEMENT) > (buf.byteLength-byteOffset) ) {\n\t\t\t\tthrow new RangeError( format( 'null2G', len*BYTES_PER_ELEMENT ) );\n\t\t\t}\n\t\t\tbuf = new Uint8Array( buf, byteOffset, len );\n\t\t}\n\t}\n\tsetReadOnly( this, '_buffer', buf );\n\tsetReadOnly( this, '_length', buf.length );\n\n\treturn this;\n}\n\n/**\n* Size (in bytes) of each array element.\n*\n* @name BYTES_PER_ELEMENT\n* @memberof BooleanArray\n* @readonly\n* @type {PositiveInteger}\n* @default 1\n*\n* @example\n* var nbytes = BooleanArray.BYTES_PER_ELEMENT;\n* // returns 1\n*/\nsetReadOnly( BooleanArray, 'BYTES_PER_ELEMENT', BYTES_PER_ELEMENT );\n\n/**\n* Constructor name.\n*\n* @name name\n* @memberof BooleanArray\n* @readonly\n* @type {string}\n* @default 'BooleanArray'\n*\n* @example\n* var str = BooleanArray.name;\n* // returns 'BooleanArray'\n*/\nsetReadOnly( BooleanArray, 'name', 'BooleanArray' );\n\n/**\n* Creates a new boolean array from an array-like object or an iterable.\n*\n* @name from\n* @memberof BooleanArray\n* @type {Function}\n* @param {(Collection|Iterable)} src - array-like object or iterable\n* @param {Function} [clbk] - callback to invoke for each source element\n* @param {*} [thisArg] - context\n* @throws {TypeError} `this` context must be a constructor\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be an array-like object or an iterable\n* @throws {TypeError} second argument must be a function\n* @returns {BooleanArray} boolean array\n*\n* @example\n* var arr = BooleanArray.from( [ true, false ] );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 2\n*\n* @example\n* function clbk( v ) {\n*     return !v;\n* }\n*\n* var arr = BooleanArray.from( [ true, false ], clbk );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 2\n*/\nsetReadOnly( BooleanArray, 'from', function from( src ) {\n\tvar thisArg;\n\tvar nargs;\n\tvar clbk;\n\tvar out;\n\tvar buf;\n\tvar tmp;\n\tvar get;\n\tvar len;\n\tvar i;\n\tif ( !isFunction( this ) ) {\n\t\tthrow new TypeError( format('null01') );\n\t}\n\tif ( !isBooleanArrayConstructor( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tnargs = arguments.length;\n\tif ( nargs > 1 ) {\n\t\tclbk = arguments[ 1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( 'null2H', clbk ) );\n\t\t}\n\t\tif ( nargs > 2 ) {\n\t\t\tthisArg = arguments[ 2 ];\n\t\t}\n\t}\n\tif ( isCollection( src ) ) {\n\t\tif ( clbk ) {\n\t\t\tlen = src.length;\n\t\t\tif ( src.get && src.set ) {\n\t\t\t\tget = accessorGetter( 'default' );\n\t\t\t} else {\n\t\t\t\tget = getter( 'default' );\n\t\t\t}\n\t\t\tout = new this( len );\n\t\t\tbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tbuf[ i ] = Boolean( clbk.call( thisArg, get( src, i ), i ) );\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t\treturn new this( src );\n\t}\n\tif ( isObject( src ) && HAS_ITERATOR_SYMBOL && isFunction( src[ ITERATOR_SYMBOL ] ) ) { // eslint-disable-line max-len\n\t\tbuf = src[ ITERATOR_SYMBOL ]();\n\t\tif ( !isFunction( buf.next ) ) {\n\t\t\tthrow new TypeError( format( 'null2J', src ) );\n\t\t}\n\t\tif ( clbk ) {\n\t\t\ttmp = fromIteratorMap( buf, clbk, thisArg );\n\t\t} else {\n\t\t\ttmp = fromIterator( buf );\n\t\t}\n\t\tlen = tmp.length;\n\t\tout = new this( len );\n\t\tbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tbuf[ i ] = tmp[ i ];\n\t\t}\n\t\treturn out;\n\t}\n\tthrow new TypeError( format( 'null2J', src ) );\n});\n\n/**\n* Creates a new boolean array from a variable number of arguments.\n*\n* @name of\n* @memberof BooleanArray\n* @type {Function}\n* @param {...*} element - array elements\n* @throws {TypeError} `this` context must be a constructor\n* @throws {TypeError} `this` must be a boolean array\n* @returns {BooleanArray} boolean array\n*\n* @example\n* var arr = BooleanArray.of( true, true, true, true );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 4\n*/\nsetReadOnly( BooleanArray, 'of', function of() {\n\tvar args;\n\tvar i;\n\tif ( !isFunction( this ) ) {\n\t\tthrow new TypeError( format('null01') );\n\t}\n\tif ( !isBooleanArrayConstructor( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\targs = [];\n\tfor ( i = 0; i < arguments.length; i++ ) {\n\t\targs.push( arguments[ i ] );\n\t}\n\treturn new this( args );\n});\n\n/**\n* Returns an array element located at integer position (index) `i`, with support for both nonnegative and negative integer indices.\n*\n* @name at\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {integer} idx - element index\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} must provide an integer\n* @returns {(boolean|void)} array element\n*\n* @example\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var v = arr.at( 0 );\n* // returns true\n*\n* v = arr.at( -1 );\n* // returns true\n*\n* v = arr.at( 100 );\n* // returns undefined\n*/\nsetReadOnly( BooleanArray.prototype, 'at', function at( idx ) {\n\tvar buf;\n\tvar len;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isInteger( idx ) ) {\n\t\tthrow new TypeError( format( 'null8A', idx ) );\n\t}\n\tlen = this._length;\n\tbuf = this._buffer;\n\tif ( idx < 0 ) {\n\t\tidx += len;\n\t}\n\tif ( idx < 0 || idx >= len ) {\n\t\treturn;\n\t}\n\treturn Boolean( buf[ idx ] );\n});\n\n/**\n* Pointer to the underlying data buffer.\n*\n* @name buffer\n* @memberof BooleanArray.prototype\n* @readonly\n* @type {ArrayBuffer}\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var buf = arr.buffer;\n* // returns <ArrayBuffer>\n*/\nsetReadOnlyAccessor( BooleanArray.prototype, 'buffer', function get() {\n\treturn this._buffer.buffer;\n});\n\n/**\n* Size (in bytes) of the array.\n*\n* @name byteLength\n* @memberof BooleanArray.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var byteLength = arr.byteLength;\n* // returns 10\n*/\nsetReadOnlyAccessor( BooleanArray.prototype, 'byteLength', function get() {\n\treturn this._buffer.byteLength;\n});\n\n/**\n* Offset (in bytes) of the array from the start of its underlying `ArrayBuffer`.\n*\n* @name byteOffset\n* @memberof BooleanArray.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var byteOffset = arr.byteOffset;\n* // returns 0\n*/\nsetReadOnlyAccessor( BooleanArray.prototype, 'byteOffset', function get() {\n\treturn this._buffer.byteOffset;\n});\n\n/**\n* Size (in bytes) of each array element.\n*\n* @name BYTES_PER_ELEMENT\n* @memberof BooleanArray.prototype\n* @readonly\n* @type {PositiveInteger}\n* @default 1\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var nbytes = arr.BYTES_PER_ELEMENT;\n* // returns 1\n*/\nsetReadOnly( BooleanArray.prototype, 'BYTES_PER_ELEMENT', BooleanArray.BYTES_PER_ELEMENT );\n\n/**\n* Copies a sequence of elements within the array to the position starting at `target`.\n*\n* @name copyWithin\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {integer} target - index at which to start copying elements\n* @param {integer} start - source index at which to copy elements from\n* @param {integer} [end] - source index at which to stop copying elements from\n* @throws {TypeError} `this` must be a boolean array\n* @returns {BooleanArray} modified array\n*\n* @example\n* var arr = new BooleanArray( 4 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( false, 2 );\n* arr.set( true, 3 );\n*\n* // Copy the first two elements to the last two elements:\n* arr.copyWithin( 2, 0, 2 );\n*\n* var v = arr.get( 2 );\n* // returns true\n*\n* v = arr.get( 3 );\n* // returns false\n*/\nsetReadOnly( BooleanArray.prototype, 'copyWithin', function copyWithin( target, start ) {\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\t// FIXME: prefer a functional `copyWithin` implementation which addresses lack of universal browser support (e.g., IE11 and Safari) or ensure that typed arrays are polyfilled\n\tif ( arguments.length === 2 ) {\n\t\tthis._buffer.copyWithin( target, start );\n\t} else {\n\t\tthis._buffer.copyWithin( target, start, arguments[2] );\n\t}\n\treturn this;\n});\n\n/**\n* Returns an iterator for iterating over array key-value pairs.\n*\n* @name entries\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @throws {TypeError} `this` must be a boolean array\n* @returns {Iterator} iterator\n*\n* @example\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var it = arr.entries();\n*\n* var v = it.next().value;\n* // returns [ 0, true ]\n*\n* v = it.next().value;\n* // returns [ 1, false ]\n*\n* v = it.next().value;\n* // returns [ 2, true ]\n*\n* var bool = it.next().done;\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'entries', function entries() {\n\tvar self;\n\tvar iter;\n\tvar len;\n\tvar buf;\n\tvar FLG;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tself = this;\n\tbuf = this._buffer;\n\tlen = this._length;\n\n\t// Initialize an iteration index:\n\ti = -1;\n\n\t// Create an iterator protocol-compliant object:\n\titer = {};\n\tsetReadOnly( iter, 'next', next );\n\tsetReadOnly( iter, 'return', end );\n\n\tif ( ITERATOR_SYMBOL ) {\n\t\tsetReadOnly( iter, ITERATOR_SYMBOL, factory );\n\t}\n\treturn iter;\n\n\t/**\n\t* Returns an iterator protocol-compliant object containing the next iterated value.\n\t*\n\t* @private\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction next() {\n\t\ti += 1;\n\t\tif ( FLG || i >= len ) {\n\t\t\treturn {\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t'value': [ i, Boolean( buf[ i ] ) ],\n\t\t\t'done': false\n\t\t};\n\t}\n\n\t/**\n\t* Finishes an iterator.\n\t*\n\t* @private\n\t* @param {*} [value] - value to return\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction end( value ) {\n\t\tFLG = true;\n\t\tif ( arguments.length ) {\n\t\t\treturn {\n\t\t\t\t'value': value,\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t'done': true\n\t\t};\n\t}\n\n\t/**\n\t* Returns a new iterator.\n\t*\n\t* @private\n\t* @returns {Iterator} iterator\n\t*/\n\tfunction factory() {\n\t\treturn self.entries();\n\t}\n});\n\n/**\n* Tests whether all elements in an array pass a test implemented by a predicate function.\n*\n* @name every\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {boolean} boolean indicating whether all elements pass a test\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( true, 1 );\n* arr.set( true, 2 );\n*\n* var bool = arr.every( predicate );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'every', function every( predicate, thisArg ) {\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tif ( !predicate.call( thisArg, Boolean( buf[ i ] ), i, this ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n});\n\n/**\n* Returns a modified typed array filled with a fill value.\n*\n* @name fill\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {boolean} value - fill value\n* @param {integer} [start=0] - starting index (inclusive)\n* @param {integer} [end] - ending index (exclusive)\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a boolean\n* @throws {TypeError} second argument must be an integer\n* @throws {TypeError} third argument must be an integer\n* @returns {BooleanArray} modified array\n*\n* @example\n* var arr = new BooleanArray( 3 );\n*\n* arr.fill( true, 1 );\n*\n* var v = arr.get( 0 );\n* // returns false\n*\n* v = arr.get( 1 );\n* // returns true\n*\n* v = arr.get( 2 );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'fill', function fill( value, start, end ) {\n\tvar buf;\n\tvar len;\n\tvar val;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isBoolean( value ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a boolean. Value: `%s`.', value ) );\n\t}\n\tbuf = this._buffer;\n\tlen = this._length;\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isInteger( start ) ) {\n\t\t\tthrow new TypeError( format( 'null7f', start ) );\n\t\t}\n\t\tif ( start < 0 ) {\n\t\t\tstart += len;\n\t\t\tif ( start < 0 ) {\n\t\t\t\tstart = 0;\n\t\t\t}\n\t\t}\n\t\tif ( arguments.length > 2 ) {\n\t\t\tif ( !isInteger( end ) ) {\n\t\t\t\tthrow new TypeError( format( 'null2z', end ) );\n\t\t\t}\n\t\t\tif ( end < 0 ) {\n\t\t\t\tend += len;\n\t\t\t\tif ( end < 0 ) {\n\t\t\t\t\tend = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( end > len ) {\n\t\t\t\tend = len;\n\t\t\t}\n\t\t} else {\n\t\t\tend = len;\n\t\t}\n\t} else {\n\t\tstart = 0;\n\t\tend = len;\n\t}\n\tif ( value ) {\n\t\tval = 1;\n\t} else {\n\t\tval = 0;\n\t}\n\tfor ( i = start; i < end; i++ ) {\n\t\tbuf[ i ] = val;\n\t}\n\treturn this;\n});\n\n/**\n* Returns a new array containing the elements of an array which pass a test implemented by a predicate function.\n*\n* @name filter\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - test function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {BooleanArray} boolean array\n*\n* @example\n* function predicate( v ) {\n*     return ( v === true );\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var out = arr.filter( predicate );\n* // returns <BooleanArray>\n*\n* var len = out.length;\n* // returns 2\n*\n* var v = out.get( 0 );\n* // returns true\n*\n* v = out.get( 1 );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'filter', function filter( predicate, thisArg ) {\n\tvar buf;\n\tvar out;\n\tvar i;\n\tvar v;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tout = [];\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tv = Boolean( buf[ i ] );\n\t\tif ( predicate.call( thisArg, v, i, this ) ) {\n\t\t\tout.push( v );\n\t\t}\n\t}\n\treturn new this.constructor( out );\n});\n\n/**\n* Returns the first element in an array for which a predicate function returns a truthy value.\n*\n* @name find\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {(boolean|void)} array element or undefined\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var v = arr.find( predicate );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'find', function find( predicate, thisArg ) {\n\tvar buf;\n\tvar v;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tv = Boolean( buf[ i ] );\n\t\tif ( predicate.call( thisArg, v, i, this ) ) {\n\t\t\treturn v;\n\t\t}\n\t}\n});\n\n/**\n* Returns the index of the first element in an array for which a predicate function returns a truthy value.\n*\n* @name findIndex\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {integer} index or -1\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var v = arr.findIndex( predicate );\n* // returns 0\n*/\nsetReadOnly( BooleanArray.prototype, 'findIndex', function findIndex( predicate, thisArg ) {\n\tvar buf;\n\tvar v;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tv = Boolean( buf[ i ] );\n\t\tif ( predicate.call( thisArg, v, i, this ) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n});\n\n/**\n* Returns the last element in an array for which a predicate function returns a truthy value.\n*\n* @name findLast\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {(boolean|void)} array element or undefined\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var v = arr.findLast( predicate );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'findLast', function findLast( predicate, thisArg ) {\n\tvar buf;\n\tvar v;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = this._length-1; i >= 0; i-- ) {\n\t\tv = Boolean( buf[ i ] );\n\t\tif ( predicate.call( thisArg, v, i, this ) ) {\n\t\t\treturn v;\n\t\t}\n\t}\n});\n\n/**\n* Returns the index of the last element in an array for which a predicate function returns a truthy value.\n*\n* @name findLastIndex\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {integer} index or -1\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var v = arr.findLastIndex( predicate );\n* // returns 2\n*/\nsetReadOnly( BooleanArray.prototype, 'findLastIndex', function findLastIndex( predicate, thisArg ) {\n\tvar buf;\n\tvar v;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = this._length-1; i >= 0; i-- ) {\n\t\tv = Boolean( buf[ i ] );\n\t\tif ( predicate.call( thisArg, v, i, this ) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n});\n\n/**\n* Invokes a function once for each array element.\n*\n* @name forEach\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} fcn - function to invoke\n* @param {*} [thisArg] - function invocation context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n*\n* @example\n* function log( v, i ) {\n*     console.log( '%s: %s', i, v.toString() );\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* arr.forEach( log );\n*/\nsetReadOnly( BooleanArray.prototype, 'forEach', function forEach( fcn, thisArg ) {\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( fcn ) ) {\n\t\tthrow new TypeError( format( 'null3c', fcn ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tfcn.call( thisArg, Boolean( buf[ i ] ), i, this );\n\t}\n});\n\n/**\n* Returns an array element.\n*\n* @name get\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {NonNegativeInteger} idx - element index\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} must provide a nonnegative integer\n* @returns {(boolean|void)} array element\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var v = arr.get( 0 );\n* // returns false\n*\n* arr.set( [ true, false ], 0 );\n*\n* v = arr.get( 0 );\n* // returns true\n*\n* v = arr.get( 100 );\n* // returns undefined\n*/\nsetReadOnly( BooleanArray.prototype, 'get', function get( idx ) {\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isNonNegativeInteger( idx ) ) {\n\t\tthrow new TypeError( format( 'null2K', idx ) );\n\t}\n\tif ( idx >= this._length ) {\n\t\treturn;\n\t}\n\treturn Boolean( this._buffer[ idx ] );\n});\n\n/**\n* Returns a boolean indicating whether an array includes a provided value.\n*\n* @name includes\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {boolean} searchElement - search element\n* @param {integer} [fromIndex=0] - starting index (inclusive)\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a boolean value\n* @throws {TypeError} second argument must be an integer\n* @returns {boolean} boolean indicating whether an array includes a value\n*\n* @example\n* var arr = new BooleanArray( 5 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n* arr.set( true, 3 );\n* arr.set( true, 4 );\n*\n* var bool = arr.includes( true );\n* // returns true\n*\n* bool = arr.includes( false, 2 );\n* // returns false\n*/\nsetReadOnly( BooleanArray.prototype, 'includes', function includes( searchElement, fromIndex ) {\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isBoolean( searchElement ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a boolean. Value: `%s`.', searchElement ) );\n\t}\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isInteger( fromIndex ) ) {\n\t\t\tthrow new TypeError( format( 'null7f', fromIndex ) );\n\t\t}\n\t\tif ( fromIndex < 0 ) {\n\t\t\tfromIndex += this._length;\n\t\t\tif ( fromIndex < 0 ) {\n\t\t\t\tfromIndex = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfromIndex = 0;\n\t}\n\tbuf = this._buffer;\n\tfor ( i = fromIndex; i < this._length; i++ ) {\n\t\tif ( searchElement === Boolean( buf[ i ] ) ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n});\n\n/**\n* Returns the first index at which a given element can be found.\n*\n* @name indexOf\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {boolean} searchElement - element to find\n* @param {integer} [fromIndex=0] - starting index (inclusive)\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a boolean value\n* @throws {TypeError} second argument must be an integer\n* @returns {integer} index or -1\n*\n* @example\n* var arr = new BooleanArray( 5 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n* arr.set( true, 3 );\n* arr.set( true, 4 );\n*\n* var idx = arr.indexOf( true );\n* // returns 0\n*\n* idx = arr.indexOf( false, 2 );\n* // returns -1\n*\n* idx = arr.indexOf( false, -3 );\n* // returns -1\n*/\nsetReadOnly( BooleanArray.prototype, 'indexOf', function indexOf( searchElement, fromIndex ) {\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isBoolean( searchElement ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a boolean. Value: `%s`.', searchElement ) );\n\t}\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isInteger( fromIndex ) ) {\n\t\t\tthrow new TypeError( format( 'null7f', fromIndex ) );\n\t\t}\n\t\tif ( fromIndex < 0 ) {\n\t\t\tfromIndex += this._length;\n\t\t\tif ( fromIndex < 0 ) {\n\t\t\t\tfromIndex = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfromIndex = 0;\n\t}\n\tbuf = this._buffer;\n\tfor ( i = fromIndex; i < this._length; i++ ) {\n\t\tif ( searchElement === Boolean( buf[ i ] ) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n});\n\n/**\n* Returns a new string by concatenating all array elements.\n*\n* @name join\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {string} [separator=','] - element separator\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a string\n* @returns {string} string representation\n*\n* @example\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var str = arr.join();\n* // returns 'true,false,true'\n*\n* str = arr.join( '|' );\n* // returns 'true|false|true'\n*/\nsetReadOnly( BooleanArray.prototype, 'join', function join( separator ) {\n\tvar buf;\n\tvar out;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( arguments.length > 0 ) {\n\t\tif ( !isString( separator ) ) {\n\t\t\tthrow new TypeError( format( 'null3F', separator ) );\n\t\t}\n\t} else {\n\t\tseparator = ',';\n\t}\n\tbuf = this._buffer;\n\tout = [];\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tif ( buf[i] ) {\n\t\t\tout.push( 'true' );\n\t\t} else {\n\t\t\tout.push( 'false' );\n\t\t}\n\t}\n\treturn out.join( separator );\n});\n\n/**\n* Returns an iterator for iterating over each index key in a typed array.\n*\n* @name keys\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @throws {TypeError} `this` must be a boolean array\n* @returns {Iterator} iterator\n*\n* @example\n* var arr = new BooleanArray( 2 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n*\n* var iter = arr.keys();\n*\n* var v = iter.next().value;\n* // returns 0\n*\n* v = iter.next().value;\n* // returns 1\n*\n* var bool = iter.next().done;\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'keys', function keys() {\n\tvar self;\n\tvar iter;\n\tvar len;\n\tvar FLG;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tself = this;\n\tlen = this._length;\n\n\t// Initialize an iteration index:\n\ti = -1;\n\n\t// Create an iterator protocol-compliant object:\n\titer = {};\n\tsetReadOnly( iter, 'next', next );\n\tsetReadOnly( iter, 'return', end );\n\n\tif ( ITERATOR_SYMBOL ) {\n\t\tsetReadOnly( iter, ITERATOR_SYMBOL, factory );\n\t}\n\treturn iter;\n\n\t/**\n\t* Returns an iterator protocol-compliant object containing the next iterated value.\n\t*\n\t* @private\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction next() {\n\t\ti += 1;\n\t\tif ( FLG || i >= len ) {\n\t\t\treturn {\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t'value': i,\n\t\t\t'done': false\n\t\t};\n\t}\n\n\t/**\n\t* Finishes an iterator.\n\t*\n\t* @private\n\t* @param {*} [value] - value to return\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction end( value ) {\n\t\tFLG = true;\n\t\tif ( arguments.length ) {\n\t\t\treturn {\n\t\t\t\t'value': value,\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t'done': true\n\t\t};\n\t}\n\n\t/**\n\t* Returns a new iterator.\n\t*\n\t* @private\n\t* @returns {Iterator} iterator\n\t*/\n\tfunction factory() {\n\t\treturn self.keys();\n\t}\n});\n\n/**\n* Returns the last index at which a given element can be found.\n*\n* @name lastIndexOf\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {boolean} searchElement - element to find\n* @param {integer} [fromIndex] - starting index (inclusive)\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a boolean value\n* @throws {TypeError} second argument must be an integer\n* @returns {integer} index or -1\n*\n* @example\n* var arr = new BooleanArray( 5 );\n*\n* arr.set( true, 0 );\n* arr.set( true, 1 );\n* arr.set( true, 2 );\n* arr.set( false, 3 );\n* arr.set( true, 4 );\n*\n* var idx = arr.lastIndexOf( true );\n* // returns 4\n*\n* idx = arr.lastIndexOf( false, 2 );\n* // returns -1\n*\n* idx = arr.lastIndexOf( false, -3 );\n* // returns -1\n*/\nsetReadOnly( BooleanArray.prototype, 'lastIndexOf', function lastIndexOf( searchElement, fromIndex ) {\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isBoolean( searchElement ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a boolean. Value: `%s`.', searchElement ) );\n\t}\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isInteger( fromIndex ) ) {\n\t\t\tthrow new TypeError( format( 'null7f', fromIndex ) );\n\t\t}\n\t\tif ( fromIndex >= this._length ) {\n\t\t\tfromIndex = this._length - 1;\n\t\t} else if ( fromIndex < 0 ) {\n\t\t\tfromIndex += this._length;\n\t\t}\n\t} else {\n\t\tfromIndex = this._length - 1;\n\t}\n\tbuf = this._buffer;\n\tfor ( i = fromIndex; i >= 0; i-- ) {\n\t\tif ( searchElement === Boolean( buf[ i ] ) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n});\n\n/**\n* Number of array elements.\n*\n* @name length\n* @memberof BooleanArray.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var len = arr.length;\n* // returns 10\n*/\nsetReadOnlyAccessor( BooleanArray.prototype, 'length', function get() {\n\treturn this._length;\n});\n\n/**\n* Returns a new array with each element being the result of a provided callback function.\n*\n* @name map\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} fcn - callback function\n* @param {*} [thisArg] - callback function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {BooleanArray} new boolean array\n*\n* @example\n* function invert( v ) {\n*     return !v;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var out = arr.map( invert );\n* // returns <BooleanArray>\n*\n* var z = out.get( 0 );\n* // returns false\n*\n* z = out.get( 1 );\n* // returns true\n*\n* z = out.get( 2 );\n* // returns false\n*/\nsetReadOnly( BooleanArray.prototype, 'map', function map( fcn, thisArg ) {\n\tvar outbuf;\n\tvar out;\n\tvar buf;\n\tvar i;\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( fcn ) ) {\n\t\tthrow new TypeError( format('null3c'), fcn );\n\t}\n\tbuf = this._buffer;\n\tout = new this.constructor( this._length );\n\toutbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\toutbuf[ i ] = Boolean( fcn.call( thisArg, Boolean( buf[ i ] ), i, this ) );\n\t}\n\treturn out;\n});\n\n/**\n* Applies a provided callback function to each element of the array, in order, passing in the return value from the calculation on the preceding element and returning the accumulated result upon completion.\n*\n* @name reduce\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} reducer - callback function\n* @param {*} [initialValue] - initial value\n* @throws {TypeError} `this` must be a boolean array\n* @throws {Error} if not provided an initial value, the array must have at least one element\n* @returns {*} accumulated result\n*\n* @example\n* function reducer( acc, v ) {\n*     if ( v ) {\n*          return acc + 1;\n*     }\n*     return acc;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var out = arr.reduce( reducer, 0 );\n* // returns 2\n*/\nsetReadOnly( BooleanArray.prototype, 'reduce', function reduce( reducer, initialValue ) {\n\tvar buf;\n\tvar len;\n\tvar acc;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( reducer ) ) {\n\t\tthrow new TypeError( format( 'null3c', reducer ) );\n\t}\n\tbuf = this._buffer;\n\tlen = this._length;\n\tif ( arguments.length > 1 ) {\n\t\tacc = initialValue;\n\t\ti = 0;\n\t} else {\n\t\tif ( len === 0 ) {\n\t\t\tthrow new Error( 'invalid operation. If not provided an initial value, an array must contain at least one element.' );\n\t\t}\n\t\tacc = Boolean( buf[ 0 ] );\n\t\ti = 1;\n\t}\n\tfor ( ; i < len; i++ ) {\n\t\tacc = reducer( acc, Boolean( buf[ i ] ), i, this );\n\t}\n\treturn acc;\n});\n\n/**\n* Applies a provided callback function to each element of the array, in reverse order, passing in the return value from the calculation on the preceding element and returning the accumulated result upon completion.\n*\n* @name reduceRight\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} reducer - callback function\n* @param {*} [initialValue] - initial value\n* @throws {TypeError} `this` must be a boolean array\n* @throws {Error} if not provided an initial value, the array must have at least one element\n* @returns {*} accumulated result\n*\n* @example\n* function reducer( acc, v ) {\n*     if ( v ) {\n*          return acc + 1;\n*     }\n*     return acc;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var out = arr.reduceRight( reducer, 0 );\n* // returns 2\n*/\nsetReadOnly( BooleanArray.prototype, 'reduceRight', function reduceRight( reducer, initialValue ) {\n\tvar buf;\n\tvar len;\n\tvar acc;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( reducer ) ) {\n\t\tthrow new TypeError( format( 'null3c', reducer ) );\n\t}\n\tbuf = this._buffer;\n\tlen = this._length;\n\tif ( arguments.length > 1 ) {\n\t\tacc = initialValue;\n\t\ti = len - 1;\n\t} else {\n\t\tif ( len === 0 ) {\n\t\t\tthrow new Error( 'invalid operation. If not provided an initial value, an array must contain at least one element.' );\n\t\t}\n\t\tacc = Boolean( buf[ len-1 ] );\n\t\ti = len - 2;\n\t}\n\tfor ( ; i >= 0; i-- ) {\n\t\tacc = reducer( acc, Boolean( buf[ i ] ), i, this );\n\t}\n\treturn acc;\n});\n\n/**\n* Reverses an array in-place.\n*\n* @name reverse\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @throws {TypeError} `this` must be a boolean array\n* @returns {BooleanArray} reversed array\n*\n* @example\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( false, 2 );\n*\n* var out = arr.reverse();\n* // returns <BooleanArray>\n*\n* var v = out.get( 0 );\n* // returns false\n*\n* v = out.get( 1 );\n* // returns false\n*\n* v = out.get( 2 );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'reverse', function reverse() {\n\tvar buf;\n\tvar tmp;\n\tvar len;\n\tvar N;\n\tvar i;\n\tvar j;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tbuf = this._buffer;\n\tlen = this._length;\n\tN = floor( len / 2 );\n\tfor ( i = 0; i < N; i++ ) {\n\t\tj = len - i - 1;\n\t\ttmp = buf[ i ];\n\t\tbuf[ i ] = buf[ j ];\n\t\tbuf[ j ] = tmp;\n\t}\n\treturn this;\n});\n\n/**\n* Sets an array element.\n*\n* ## Notes\n*\n* -   When provided a typed array, we must check whether the source array shares the same buffer as the target array and whether the underlying memory overlaps. In particular, we are concerned with the following scenario:\n*\n*     ```text\n*     buf:                ---------------------\n*     src: ---------------------\n*     ```\n*\n*     In the above, as we copy values from `src`, we will overwrite values in the `src` view, resulting in duplicated values copied into the end of `buf`, which is not intended. Hence, to avoid overwriting source values, we must **copy** source values to a temporary array.\n*\n*     In the other overlapping scenario,\n*\n*     ```text\n*     buf: ---------------------\n*     src:                ---------------------\n*     ```\n*\n*     by the time we begin copying into the overlapping region, we are copying from the end of `src`, a non-overlapping region, which means we don't run the risk of copying copied values, rather than the original `src` values, as intended.\n*\n* @name set\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {(Collection|BooleanArray|*)} value - value(s)\n* @param {NonNegativeInteger} [i=0] - element index at which to start writing values\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} index argument must be a nonnegative integer\n* @throws {RangeError} index argument is out-of-bounds\n* @throws {RangeError} target array lacks sufficient storage to accommodate source values\n* @returns {void}\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var v = arr.get( 0 );\n* // returns false\n*\n* arr.set( [ true, false ], 0 );\n*\n* v = arr.get( 0 );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'set', function set( value ) {\n\tvar sbuf;\n\tvar idx;\n\tvar buf;\n\tvar tmp;\n\tvar N;\n\tvar i;\n\tvar j;\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tbuf = this._buffer;\n\tif ( arguments.length > 1 ) {\n\t\tidx = arguments[ 1 ];\n\t\tif ( !isNonNegativeInteger( idx ) ) {\n\t\t\tthrow new TypeError( format( 'null2L', idx ) );\n\t\t}\n\t} else {\n\t\tidx = 0;\n\t}\n\tif ( isCollection( value ) ) {\n\t\tN = value.length;\n\t\tif ( idx+N > this._length ) {\n\t\t\tthrow new RangeError( format('null03') );\n\t\t}\n\t\tif ( isBooleanArray( value ) ) {\n\t\t\tsbuf = value._buffer; // eslint-disable-line no-underscore-dangle\n\t\t} else {\n\t\t\tsbuf = value;\n\t\t}\n\t\t// Check for overlapping memory...\n\t\tj = buf.byteOffset + (idx*BYTES_PER_ELEMENT);\n\t\tif (\n\t\t\tsbuf.buffer === buf.buffer &&\n\t\t\t(\n\t\t\t\tsbuf.byteOffset < j &&\n\t\t\t\tsbuf.byteOffset+sbuf.byteLength > j\n\t\t\t)\n\t\t) {\n\t\t\t// We need to copy source values...\n\t\t\ttmp = new Uint8Array( sbuf.length );\n\t\t\tfor ( i = 0; i < sbuf.length; i++ ) {\n\t\t\t\ttmp[ i ] = sbuf[ i ]; // TODO: handle accessor arrays\n\t\t\t}\n\t\t\tsbuf = tmp;\n\t\t}\n\t\tfor ( i = 0; i < N; idx++, i++ ) {\n\t\t\tbuf[ idx ] = ( sbuf[ i ] ) ? 1 : 0;\n\t\t}\n\t\treturn;\n\t}\n\tif ( idx >= this._length ) {\n\t\tthrow new RangeError( format( 'null2M', idx ) );\n\t}\n\tbuf[ idx ] = ( value ) ? 1 : 0;\n});\n\n/**\n* Copies a portion of a typed array to a new typed array.\n*\n* @name slice\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {integer} [begin] - start index (inclusive)\n* @param {integer} [end] - end index (exclusive)\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be integer\n* @throws {TypeError} second argument must be integer\n* @returns {BooleanArray} boolean array\n*\n* @example\n* var arr = new BooleanArray( 5 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n* arr.set( false, 3 );\n* arr.set( true, 4 );\n*\n* var out = arr.slice();\n* // returns <BooleanArray>\n*\n* var len = out.length;\n* // returns 5\n*\n* var bool = out.get( 0 );\n* // returns true\n*\n* bool = out.get( len-1 );\n* // returns true\n*\n* out = arr.slice( 1, -2 );\n* // returns <BooleanArray>\n*\n* len = out.length;\n* // returns 2\n*\n* bool = out.get( 0 );\n* // returns false\n*\n* bool = out.get( len-1 );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'slice', function slice( begin, end ) {\n\tvar outlen;\n\tvar outbuf;\n\tvar out;\n\tvar buf;\n\tvar len;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tbuf = this._buffer;\n\tlen = this._length;\n\tif ( arguments.length === 0 ) {\n\t\tbegin = 0;\n\t\tend = len;\n\t} else {\n\t\tif ( !isInteger( begin ) ) {\n\t\t\tthrow new TypeError( format( 'null7e', begin ) );\n\t\t}\n\t\tif ( begin < 0 ) {\n\t\t\tbegin += len;\n\t\t\tif ( begin < 0 ) {\n\t\t\t\tbegin = 0;\n\t\t\t}\n\t\t}\n\t\tif ( arguments.length === 1 ) {\n\t\t\tend = len;\n\t\t} else {\n\t\t\tif ( !isInteger( end ) ) {\n\t\t\t\tthrow new TypeError( format( 'null7f', end ) );\n\t\t\t}\n\t\t\tif ( end < 0 ) {\n\t\t\t\tend += len;\n\t\t\t\tif ( end < 0 ) {\n\t\t\t\t\tend = 0;\n\t\t\t\t}\n\t\t\t} else if ( end > len ) {\n\t\t\t\tend = len;\n\t\t\t}\n\t\t}\n\t}\n\tif ( begin < end ) {\n\t\toutlen = end - begin;\n\t} else {\n\t\toutlen = 0;\n\t}\n\tout = new this.constructor( outlen );\n\toutbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\tfor ( i = 0; i < outlen; i++ ) {\n\t\toutbuf[ i ] = buf[ i+begin ];\n\t}\n\treturn out;\n});\n\n/**\n* Tests whether at least one element in an array passes a test implemented by a predicate function.\n*\n* @name some\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {boolean} boolean indicating whether at least one element passes a test\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( false, 0 );\n* arr.set( true, 1 );\n* arr.set( false, 2 );\n*\n* var bool = arr.some( predicate );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'some', function some( predicate, thisArg ) {\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tif ( predicate.call( thisArg, Boolean( buf[ i ] ), i, this ) ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n});\n\n/**\n* Sorts an array in-place.\n*\n* @name sort\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} [compareFcn] - comparison function\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {BooleanArray} sorted array\n*\n* @example\n* function compare( a, b ) {\n*    if ( a === false ) {\n*        if ( b === false ) {\n*            return 0;\n*        }\n*        return 1;\n*    }\n*    if ( b === true ) {\n*        return 0;\n*    }\n*    return -1;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* arr.sort( compare );\n*\n* var v = arr.get( 0 );\n* // returns true\n*\n* v = arr.get( 1 );\n* // returns true\n*\n* v = arr.get( 2 );\n* // returns false\n*/\nsetReadOnly( BooleanArray.prototype, 'sort', function sort( compareFcn ) {\n\tvar buf;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tbuf = this._buffer;\n\tif ( arguments.length === 0 ) {\n\t\tbuf.sort();\n\t\treturn this;\n\t}\n\tif ( !isFunction( compareFcn ) ) {\n\t\tthrow new TypeError( format( 'null3c', compareFcn ) );\n\t}\n\tbuf.sort( compare );\n\treturn this;\n\n\t/**\n\t* Comparison function for sorting.\n\t*\n\t* @private\n\t* @param {boolean} a - first boolean value for comparison\n\t* @param {boolean} b - second boolean value for comparison\n\t* @returns {number} comparison result\n\t*/\n\tfunction compare( a, b ) {\n\t\treturn compareFcn( Boolean( a ), Boolean( b ) );\n\t}\n});\n\n/**\n* Creates a new typed array view over the same underlying `ArrayBuffer` and with the same underlying data type as the host array.\n*\n* @name subarray\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {integer} [begin] - start index (inclusive)\n* @param {integer} [end] - end index (exclusive)\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be an integer\n* @throws {TypeError} second argument must be an integer\n* @returns {BooleanArray} subarray\n*\n* @example\n* var arr = new BooleanArray( 5 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n* arr.set( false, 3 );\n* arr.set( true, 4 );\n*\n* var subarr = arr.subarray();\n* // returns <BooleanArray>\n*\n* var len = subarr.length;\n* // returns 5\n*\n* var bool = subarr.get( 0 );\n* // returns true\n*\n* bool = subarr.get( len-1 );\n* // returns true\n*\n* subarr = arr.subarray( 1, -2 );\n* // returns <BooleanArray>\n*\n* len = subarr.length;\n* // returns 2\n*\n* bool = subarr.get( 0 );\n* // returns false\n*\n* bool = subarr.get( len-1 );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'subarray', function subarray( begin, end ) {\n\tvar offset;\n\tvar buf;\n\tvar len;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tbuf = this._buffer;\n\tlen = this._length;\n\tif ( arguments.length === 0 ) {\n\t\tbegin = 0;\n\t\tend = len;\n\t} else {\n\t\tif ( !isInteger( begin ) ) {\n\t\t\tthrow new TypeError( format( 'null7e', begin ) );\n\t\t}\n\t\tif ( begin < 0 ) {\n\t\t\tbegin += len;\n\t\t\tif ( begin < 0 ) {\n\t\t\t\tbegin = 0;\n\t\t\t}\n\t\t}\n\t\tif ( arguments.length === 1 ) {\n\t\t\tend = len;\n\t\t} else {\n\t\t\tif ( !isInteger( end ) ) {\n\t\t\t\tthrow new TypeError( format( 'null7f', end ) );\n\t\t\t}\n\t\t\tif ( end < 0 ) {\n\t\t\t\tend += len;\n\t\t\t\tif ( end < 0 ) {\n\t\t\t\t\tend = 0;\n\t\t\t\t}\n\t\t\t} else if ( end > len ) {\n\t\t\t\tend = len;\n\t\t\t}\n\t\t}\n\t}\n\tif ( begin >= len ) {\n\t\tlen = 0;\n\t\toffset = buf.byteLength;\n\t} else if ( begin >= end ) {\n\t\tlen = 0;\n\t\toffset = buf.byteOffset + ( begin*BYTES_PER_ELEMENT );\n\t} else {\n\t\tlen = end - begin;\n\t\toffset = buf.byteOffset + ( begin*BYTES_PER_ELEMENT );\n\t}\n\treturn new this.constructor( buf.buffer, offset, ( len < 0 ) ? 0 : len );\n});\n\n/**\n* Serializes an array as a locale-specific string.\n*\n* @name toLocaleString\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {(string|Array<string>)} [locales] - locale identifier(s)\n* @param {Object} [options] - configuration options\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a string or an array of strings\n* @throws {TypeError} options argument must be an object\n* @returns {string} string representation\n*\n* @example\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var str = arr.toLocaleString();\n* // returns 'true,false,true'\n*/\nsetReadOnly( BooleanArray.prototype, 'toLocaleString', function toLocaleString( locales, options ) {\n\tvar opts;\n\tvar loc;\n\tvar out;\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( arguments.length === 0 ) {\n\t\tloc = [];\n\t} else if ( isString( locales ) || isStringArray( locales ) ) {\n\t\tloc = locales;\n\t} else {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a string or an array of strings. Value: `%s`.', locales ) );\n\t}\n\tif ( arguments.length < 2 ) {\n\t\topts = {};\n\t} else if ( isObject( options ) ) {\n\t\topts = options;\n\t} else {\n\t\tthrow new TypeError( format( 'null2V', options ) );\n\t}\n\tbuf = this._buffer;\n\tout = [];\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tout.push( Boolean( buf[ i ] ).toLocaleString( loc, opts ) );\n\t}\n\treturn out.join( ',' );\n});\n\n/**\n* Returns a new typed array containing the elements in reversed order.\n*\n* @name toReversed\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @throws {TypeError} `this` must be a boolean array\n* @returns {BooleanArray} reversed array\n*\n* @example\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( false, 2 );\n*\n* var out = arr.toReversed();\n* // returns <BooleanArray>\n*\n* var v = out.get( 0 );\n* // returns false\n*\n* v = out.get( 1 );\n* // returns false\n*\n* v = out.get( 2 );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'toReversed', function toReversed() {\n\tvar outbuf;\n\tvar out;\n\tvar len;\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tlen = this._length;\n\tout = new this.constructor( len );\n\tbuf = this._buffer;\n\toutbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\tfor ( i = 0; i < len; i++ ) {\n\t\toutbuf[ i ] = buf[ len - i - 1 ];\n\t}\n\treturn out;\n});\n\n/**\n* Returns a new typed array containing the elements in sorted order.\n*\n* @name toSorted\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} [compareFcn] - comparison function\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {BooleanArray} sorted array\n*\n* @example\n* function compare( a, b ) {\n*    if ( a === false ) {\n*        if ( b === false ) {\n*            return 0;\n*        }\n*        return 1;\n*    }\n*    if ( b === true ) {\n*        return 0;\n*    }\n*    return -1;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var out = arr.sort( compare );\n* // returns <BooleanArray>\n*\n* var v = out.get( 0 );\n* // returns true\n*\n* v = out.get( 1 );\n* // returns true\n*\n* v = out.get( 2 );\n* // returns false\n*/\nsetReadOnly( BooleanArray.prototype, 'toSorted', function toSorted( compareFcn ) {\n\tvar outbuf;\n\tvar out;\n\tvar len;\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tlen = this._length;\n\tout = new this.constructor( len );\n\tbuf = this._buffer;\n\toutbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\tfor ( i = 0; i < len; i++ ) {\n\t\toutbuf[ i ] = buf[ i ];\n\t}\n\tif ( arguments.length === 0 ) {\n\t\toutbuf.sort();\n\t\treturn out;\n\t}\n\tif ( !isFunction( compareFcn ) ) {\n\t\tthrow new TypeError( format( 'null3c', compareFcn ) );\n\t}\n\toutbuf.sort( compare );\n\treturn out;\n\n\t/**\n\t* Comparison function for sorting.\n\t*\n\t* @private\n\t* @param {boolean} a - first boolean value for comparison\n\t* @param {boolean} b - second boolean value for comparison\n\t* @returns {number} comparison result\n\t*/\n\tfunction compare( a, b ) {\n\t\treturn compareFcn( Boolean( a ), Boolean( b ) );\n\t}\n});\n\n/**\n* Serializes an array as a string.\n*\n* @name toString\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @throws {TypeError} `this` must be a boolean array\n* @returns {string} string representation\n*\n* @example\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var str = arr.toString();\n* // returns 'true,false,true'\n*/\nsetReadOnly( BooleanArray.prototype, 'toString', function toString() {\n\tvar out;\n\tvar buf;\n\tvar i;\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tout = [];\n\tbuf = this._buffer;\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tif ( buf[i] ) {\n\t\t\tout.push( 'true' );\n\t\t} else {\n\t\t\tout.push( 'false' );\n\t\t}\n\t}\n\treturn out.join( ',' );\n});\n\n/**\n* Returns an iterator for iterating over each value in a typed array.\n*\n* @name values\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @throws {TypeError} `this` must be a boolean array\n* @returns {Iterator} iterator\n*\n* @example\n* var arr = new BooleanArray( 2 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n*\n* var iter = arr.values();\n*\n* var v = iter.next().value;\n* // returns true\n*\n* v = iter.next().value;\n* // returns false\n*\n* var bool = iter.next().done;\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'values', function values() {\n\tvar iter;\n\tvar self;\n\tvar len;\n\tvar FLG;\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tself = this;\n\tbuf = this._buffer;\n\tlen = this._length;\n\n\t// Initialize an iteration index:\n\ti = -1;\n\n\t// Create an iterator protocol-compliant object:\n\titer = {};\n\tsetReadOnly( iter, 'next', next );\n\tsetReadOnly( iter, 'return', end );\n\n\tif ( ITERATOR_SYMBOL ) {\n\t\tsetReadOnly( iter, ITERATOR_SYMBOL, factory );\n\t}\n\treturn iter;\n\n\t/**\n\t* Returns an iterator protocol-compliant object containing the next iterated value.\n\t*\n\t* @private\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction next() {\n\t\ti += 1;\n\t\tif ( FLG || i >= len ) {\n\t\t\treturn {\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t'value': Boolean( buf[ i ] ),\n\t\t\t'done': false\n\t\t};\n\t}\n\n\t/**\n\t* Finishes an iterator.\n\t*\n\t* @private\n\t* @param {*} [value] - value to return\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction end( value ) {\n\t\tFLG = true;\n\t\tif ( arguments.length ) {\n\t\t\treturn {\n\t\t\t\t'value': value,\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t'done': true\n\t\t};\n\t}\n\n\t/**\n\t* Returns a new iterator.\n\t*\n\t* @private\n\t* @returns {Iterator} iterator\n\t*/\n\tfunction factory() {\n\t\treturn self.values();\n\t}\n});\n\n/**\n* Returns a new typed array with the element at a provided index replaced with a provided value.\n*\n* @name with\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {integer} index - element index\n* @param {boolean} value - new value\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be an integer\n* @throws {RangeError} index argument is out-of-bounds\n* @throws {TypeError} second argument must be a boolean\n* @returns {BooleanArray} new typed array\n*\n* @example\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var out = arr.with( 0, false );\n* // returns <BooleanArray>\n*\n* var v = out.get( 0 );\n* // returns false\n*/\nsetReadOnly( BooleanArray.prototype, 'with', function copyWith( index, value ) {\n\tvar buf;\n\tvar out;\n\tvar len;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isInteger( index ) ) {\n\t\tthrow new TypeError( format( 'null7e', index ) );\n\t}\n\tlen = this._length;\n\tif ( index < 0 ) {\n\t\tindex += len;\n\t}\n\tif ( index < 0 || index >= len ) {\n\t\tthrow new RangeError( format( 'nullFP', index ) );\n\t}\n\tif ( !isBoolean( value ) ) {\n\t\tthrow new TypeError( format( 'null55', value ) );\n\t}\n\tout = new this.constructor( this._buffer );\n\tbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\tif ( value ) {\n\t\tbuf[ index ] = 1;\n\t} else {\n\t\tbuf[ index ] = 0;\n\t}\n\treturn out;\n});\n\n\n// EXPORTS //\n\nexport default BooleanArray;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Boolean from '@stdlib/boolean-ctor';\n\n\n// MAIN //\n\n/**\n* Fills an output array with \"boolean\" values.\n*\n* @private\n* @param {Uint8Array} buf - output array\n* @param {Array} arr - input array\n* @returns {Uint8Array} output array\n*/\nfunction fromArray( buf, arr ) {\n\tvar len;\n\tvar i;\n\n\tlen = arr.length;\n\tfor ( i = 0; i < len; i++ ) {\n\t\tbuf[ i ] = Boolean( arr[ i ] );\n\t}\n\treturn buf;\n}\n\n\n// EXPORTS //\n\nexport default fromArray;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Boolean from '@stdlib/boolean-ctor';\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @param {Function} clbk - callback to invoke for each iterated value\n* @param {*} thisArg - invocation context\n* @returns {Array} output array\n*/\nfunction fromIteratorMap( it, clbk, thisArg ) {\n\tvar out;\n\tvar v;\n\tvar i;\n\n\tout = [];\n\ti = -1;\n\twhile ( true ) {\n\t\tv = it.next();\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t\ti += 1;\n\t\tout.push( Boolean( clbk.call( thisArg, v.value, i ) ) );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default fromIteratorMap;\n"],"names":["fromIterator","it","out","v","next","done","push","Boolean","value","BYTES_PER_ELEMENT","Uint8Array","HAS_ITERATOR_SYMBOL","hasIteratorSymbolSupport","isBooleanArray","constructor","name","isBooleanArrayConstructor","BooleanArray","byteOffset","nargs","buf","len","arg","arguments","length","this","isNonNegativeInteger","isCollection","arr","i","fromArray","isArrayBuffer","isObject","TypeError","format","isFunction","ITERATOR_SYMBOL","byteLength","RangeError","setReadOnly","src","thisArg","clbk","tmp","get","set","accessorGetter","getter","_buffer","call","fromIteratorMap","args","prototype","idx","isInteger","_length","setReadOnlyAccessor","buffer","target","start","copyWithin","self","iter","FLG","entries","predicate","end","val","isBoolean","fcn","searchElement","fromIndex","separator","isString","join","keys","outbuf","reducer","initialValue","acc","Error","N","j","floor","sbuf","begin","outlen","compareFcn","sort","a","b","offset","locales","options","opts","loc","isStringArray","toLocaleString","values","index"],"mappings":"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"}