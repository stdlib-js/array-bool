{"version":3,"file":"index.mjs","sources":["../lib/from_iterator.js","../lib/main.js","../lib/from_array.js","../lib/from_iterator_map.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Boolean from '@stdlib/boolean-ctor';\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @returns {Array} output array\n*/\nfunction fromIterator( it ) {\n\tvar out;\n\tvar v;\n\n\tout = [];\n\twhile ( true ) {\n\t\tv = it.next();\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t\tout.push( Boolean( v.value ) );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default fromIterator;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this */\n\n'use strict';\n\n// MODULES //\n\nimport { isPrimitive as isNonNegativeInteger } from '@stdlib/assert-is-nonnegative-integer';\nimport isCollection from '@stdlib/assert-is-collection';\nimport isArrayBuffer from '@stdlib/assert-is-arraybuffer';\nimport isObject from '@stdlib/assert-is-object';\nimport isFunction from '@stdlib/assert-is-function';\nimport hasIteratorSymbolSupport from '@stdlib/assert-has-iterator-symbol-support';\nimport ITERATOR_SYMBOL from '@stdlib/symbol-iterator';\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport setReadOnlyAccessor from '@stdlib/utils-define-nonenumerable-read-only-accessor';\nimport Uint8Array from '@stdlib/array-uint8';\nimport Boolean from '@stdlib/boolean-ctor';\nimport getter from '@stdlib/array-base-getter';\nimport floor from '@stdlib/math-base-special-floor';\nimport accessorGetter from '@stdlib/array-base-accessor-getter';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport fromIterator from './from_iterator.js';\nimport fromIteratorMap from './from_iterator_map.js';\nimport fromArray from './from_array.js';\n\n\n// VARIABLES //\n\nvar BYTES_PER_ELEMENT = Uint8Array.BYTES_PER_ELEMENT;\nvar HAS_ITERATOR_SYMBOL = hasIteratorSymbolSupport();\n\n\n// FUNCTIONS //\n\n/**\n* Returns a boolean indicating if a value is a `BooleanArray`.\n*\n* @private\n* @param {*} value - value to test\n* @returns {boolean} boolean indicating if a value is a `BooleanArray`\n*/\nfunction isBooleanArray( value ) {\n\treturn (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\tvalue.constructor.name === 'BooleanArray' &&\n\t\tvalue.BYTES_PER_ELEMENT === BYTES_PER_ELEMENT\n\t);\n}\n\n/**\n* Returns a boolean indicating if a value is a boolean typed array constructor.\n*\n* @private\n* @param {*} value - value to test\n* @returns {boolean} boolean indicating if a value is a boolean typed array constructor\n*/\nfunction isBooleanArrayConstructor( value ) {\n\treturn ( value === BooleanArray);\n}\n\n\n// MAIN //\n\n/**\n* Boolean array constructor.\n*\n* @constructor\n* @param {(NonNegativeInteger|Collection|ArrayBuffer|Iterable)} [arg] - length, typed array, array-like object, buffer, or an iterable\n* @param {NonNegativeInteger} [byteOffset=0] - byte offset\n* @param {NonNegativeInteger} [length] - view length\n* @throws {TypeError} if provided only a single argument, must provide a valid argument\n* @throws {TypeError} byte offset must be a nonnegative integer\n* @throws {RangeError} must provide sufficient memory to accommodate byte offset and view length requirements\n* @returns {BooleanArray} boolean array\n*\n* @example\n* var arr = new BooleanArray();\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 0\n*\n* @example\n* var arr = new BooleanArray( 2 );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 2\n*\n* @example\n* var arr = new BooleanArray( [ true, false ] );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 2\n*\n* @example\n* import ArrayBuffer from '@stdlib/array-buffer';\n*\n* var buf = new ArrayBuffer( 16 );\n* var arr = new BooleanArray( buf );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 16\n*\n* @example\n* import ArrayBuffer from '@stdlib/array-buffer';\n*\n* var buf = new ArrayBuffer( 16 );\n* var arr = new BooleanArray( buf, 8 );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 8\n*\n* @example\n* import ArrayBuffer from '@stdlib/array-buffer';\n*\n* var buf = new ArrayBuffer( 32 );\n* var arr = new BooleanArray( buf, 8, 2 );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 2\n*/\nfunction BooleanArray() {\n\tvar byteOffset;\n\tvar nargs;\n\tvar buf;\n\tvar len;\n\tvar arg;\n\n\tnargs = arguments.length;\n\tif ( !(this instanceof BooleanArray) ) {\n\t\tif ( nargs === 0 ) {\n\t\t\treturn new BooleanArray();\n\t\t}\n\t\tif ( nargs === 1 ) {\n\t\t\treturn new BooleanArray( arguments[0] );\n\t\t}\n\t\tif ( nargs === 2 ) {\n\t\t\treturn new BooleanArray( arguments[0], arguments[1] );\n\t\t}\n\t\treturn new BooleanArray( arguments[0], arguments[1], arguments[2] );\n\t}\n\t// Create the underlying data buffer...\n\tif ( nargs === 0 ) {\n\t\tbuf = new Uint8Array( 0 ); // backward-compatibility\n\t} else if ( nargs === 1 ) {\n\t\targ = arguments[ 0 ];\n\t\tif ( isNonNegativeInteger( arg ) ) {\n\t\t\tbuf = new Uint8Array( arg );\n\t\t} else if ( isCollection( arg ) ) {\n\t\t\tbuf = fromArray( new Uint8Array( arg.length ), arg );\n\t\t} else if ( isArrayBuffer( arg ) ) {\n\t\t\tbuf = new Uint8Array( arg );\n\t\t} else if ( isObject( arg ) ) {\n\t\t\tif ( HAS_ITERATOR_SYMBOL === false ) {\n\t\t\t\tthrow new TypeError( format( 'null29', arg ) );\n\t\t\t}\n\t\t\tif ( !isFunction( arg[ ITERATOR_SYMBOL ] ) ) {\n\t\t\t\tthrow new TypeError( format( 'null2A', arg ) );\n\t\t\t}\n\t\t\tbuf = arg[ ITERATOR_SYMBOL ]();\n\t\t\tif ( !isFunction( buf.next ) ) {\n\t\t\t\tthrow new TypeError( format( 'null2A', arg ) );\n\t\t\t}\n\t\t\tbuf = new Uint8Array( fromIterator( buf ) );\n\t\t} else {\n\t\t\tthrow new TypeError( format( 'null2A', arg ) );\n\t\t}\n\t} else {\n\t\tbuf = arguments[ 0 ];\n\t\tif ( !isArrayBuffer( buf ) ) {\n\t\t\tthrow new TypeError( format( 'null2B', buf ) );\n\t\t}\n\t\tbyteOffset = arguments[ 1 ];\n\t\tif ( !isNonNegativeInteger( byteOffset ) ) {\n\t\t\tthrow new TypeError( format( 'null2C', byteOffset ) );\n\t\t}\n\t\tif ( nargs === 2 ) {\n\t\t\tbuf = new Uint8Array( buf, byteOffset );\n\t\t} else {\n\t\t\tlen = arguments[ 2 ];\n\t\t\tif ( !isNonNegativeInteger( len ) ) {\n\t\t\t\tthrow new TypeError( format( 'null2F', len ) );\n\t\t\t}\n\t\t\tif ( (len*BYTES_PER_ELEMENT) > (buf.byteLength-byteOffset) ) {\n\t\t\t\tthrow new RangeError( format( 'null2G', len*BYTES_PER_ELEMENT ) );\n\t\t\t}\n\t\t\tbuf = new Uint8Array( buf, byteOffset, len );\n\t\t}\n\t}\n\tsetReadOnly( this, '_buffer', buf );\n\tsetReadOnly( this, '_length', buf.length );\n\n\treturn this;\n}\n\n/**\n* Size (in bytes) of each array element.\n*\n* @name BYTES_PER_ELEMENT\n* @memberof BooleanArray\n* @readonly\n* @type {PositiveInteger}\n* @default 1\n*\n* @example\n* var nbytes = BooleanArray.BYTES_PER_ELEMENT;\n* // returns 1\n*/\nsetReadOnly( BooleanArray, 'BYTES_PER_ELEMENT', BYTES_PER_ELEMENT );\n\n/**\n* Constructor name.\n*\n* @name name\n* @memberof BooleanArray\n* @readonly\n* @type {string}\n* @default 'BooleanArray'\n*\n* @example\n* var str = BooleanArray.name;\n* // returns 'BooleanArray'\n*/\nsetReadOnly( BooleanArray, 'name', 'BooleanArray' );\n\n/**\n* Creates a new boolean array from an array-like object or an iterable.\n*\n* @name from\n* @memberof BooleanArray\n* @type {Function}\n* @param {(Collection|Iterable)} src - array-like object or iterable\n* @param {Function} [clbk] - callback to invoke for each source element\n* @param {*} [thisArg] - context\n* @throws {TypeError} `this` context must be a constructor\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be an array-like object or an iterable\n* @throws {TypeError} second argument must be a function\n* @returns {BooleanArray} boolean array\n*\n* @example\n* var arr = BooleanArray.from( [ true, false ] );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 2\n*\n* @example\n* function clbk( v ) {\n*     return !v;\n* }\n*\n* var arr = BooleanArray.from( [ true, false ], clbk );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 2\n*/\nsetReadOnly( BooleanArray, 'from', function from( src ) {\n\tvar thisArg;\n\tvar nargs;\n\tvar clbk;\n\tvar out;\n\tvar buf;\n\tvar tmp;\n\tvar get;\n\tvar len;\n\tvar i;\n\tif ( !isFunction( this ) ) {\n\t\tthrow new TypeError( format('null01') );\n\t}\n\tif ( !isBooleanArrayConstructor( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tnargs = arguments.length;\n\tif ( nargs > 1 ) {\n\t\tclbk = arguments[ 1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( 'null2H', clbk ) );\n\t\t}\n\t\tif ( nargs > 2 ) {\n\t\t\tthisArg = arguments[ 2 ];\n\t\t}\n\t}\n\tif ( isCollection( src ) ) {\n\t\tif ( clbk ) {\n\t\t\tlen = src.length;\n\t\t\tif ( src.get && src.set ) {\n\t\t\t\tget = accessorGetter( 'default' );\n\t\t\t} else {\n\t\t\t\tget = getter( 'default' );\n\t\t\t}\n\t\t\tout = new this( len );\n\t\t\tbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tbuf[ i ] = Boolean( clbk.call( thisArg, get( src, i ), i ) );\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t\treturn new this( src );\n\t}\n\tif ( isObject( src ) && HAS_ITERATOR_SYMBOL && isFunction( src[ ITERATOR_SYMBOL ] ) ) { // eslint-disable-line max-len\n\t\tbuf = src[ ITERATOR_SYMBOL ]();\n\t\tif ( !isFunction( buf.next ) ) {\n\t\t\tthrow new TypeError( format( 'null2J', src ) );\n\t\t}\n\t\tif ( clbk ) {\n\t\t\ttmp = fromIteratorMap( buf, clbk, thisArg );\n\t\t} else {\n\t\t\ttmp = fromIterator( buf );\n\t\t}\n\t\tlen = tmp.length;\n\t\tout = new this( len );\n\t\tbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tbuf[ i ] = tmp[ i ];\n\t\t}\n\t\treturn out;\n\t}\n\tthrow new TypeError( format( 'null2J', src ) );\n});\n\n/**\n* Creates a new boolean array from a variable number of arguments.\n*\n* @name of\n* @memberof BooleanArray\n* @type {Function}\n* @param {...*} element - array elements\n* @throws {TypeError} `this` context must be a constructor\n* @throws {TypeError} `this` must be a boolean array\n* @returns {BooleanArray} boolean array\n*\n* @example\n* var arr = BooleanArray.of( true, true, true, true );\n* // returns <BooleanArray>\n*\n* var len = arr.length;\n* // returns 4\n*/\nsetReadOnly( BooleanArray, 'of', function of() {\n\tvar args;\n\tvar i;\n\tif ( !isFunction( this ) ) {\n\t\tthrow new TypeError( format('null01') );\n\t}\n\tif ( !isBooleanArrayConstructor( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\targs = [];\n\tfor ( i = 0; i < arguments.length; i++ ) {\n\t\targs.push( arguments[ i ] );\n\t}\n\treturn new this( args );\n});\n\n/**\n* Pointer to the underlying data buffer.\n*\n* @name buffer\n* @memberof BooleanArray.prototype\n* @readonly\n* @type {ArrayBuffer}\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var buf = arr.buffer;\n* // returns <ArrayBuffer>\n*/\nsetReadOnlyAccessor( BooleanArray.prototype, 'buffer', function get() {\n\treturn this._buffer.buffer;\n});\n\n/**\n* Size (in bytes) of the array.\n*\n* @name byteLength\n* @memberof BooleanArray.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var byteLength = arr.byteLength;\n* // returns 10\n*/\nsetReadOnlyAccessor( BooleanArray.prototype, 'byteLength', function get() {\n\treturn this._buffer.byteLength;\n});\n\n/**\n* Offset (in bytes) of the array from the start of its underlying `ArrayBuffer`.\n*\n* @name byteOffset\n* @memberof BooleanArray.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var byteOffset = arr.byteOffset;\n* // returns 0\n*/\nsetReadOnlyAccessor( BooleanArray.prototype, 'byteOffset', function get() {\n\treturn this._buffer.byteOffset;\n});\n\n/**\n* Size (in bytes) of each array element.\n*\n* @name BYTES_PER_ELEMENT\n* @memberof BooleanArray.prototype\n* @readonly\n* @type {PositiveInteger}\n* @default 1\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var nbytes = arr.BYTES_PER_ELEMENT;\n* // returns 1\n*/\nsetReadOnly( BooleanArray.prototype, 'BYTES_PER_ELEMENT', BooleanArray.BYTES_PER_ELEMENT );\n\n/**\n* Tests whether all elements in an array pass a test implemented by a predicate function.\n*\n* @name every\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {boolean} boolean indicating whether all elements pass a test\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( true, 1 );\n* arr.set( true, 2 );\n*\n* var bool = arr.every( predicate );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'every', function every( predicate, thisArg ) {\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tif ( !predicate.call( thisArg, Boolean( buf[ i ] ), i, this ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n});\n\n/**\n* Returns the first element in an array for which a predicate function returns a truthy value.\n*\n* @name find\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {(boolean|void)} array element or undefined\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var v = arr.find( predicate );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'find', function find( predicate, thisArg ) {\n\tvar buf;\n\tvar v;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tv = Boolean( buf[ i ] );\n\t\tif ( predicate.call( thisArg, v, i, this ) ) {\n\t\t\treturn v;\n\t\t}\n\t}\n});\n\n/**\n* Returns the index of the first element in an array for which a predicate function returns a truthy value.\n*\n* @name findIndex\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {integer} index or -1\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var v = arr.findIndex( predicate );\n* // returns 0\n*/\nsetReadOnly( BooleanArray.prototype, 'findIndex', function findIndex( predicate, thisArg ) {\n\tvar buf;\n\tvar v;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tv = Boolean( buf[ i ] );\n\t\tif ( predicate.call( thisArg, v, i, this ) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n});\n\n/**\n* Returns the last element in an array for which a predicate function returns a truthy value.\n*\n* @name findLast\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {(boolean|void)} array element or undefined\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var v = arr.findLast( predicate );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'findLast', function findLast( predicate, thisArg ) {\n\tvar buf;\n\tvar v;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = this._length-1; i >= 0; i-- ) {\n\t\tv = Boolean( buf[ i ] );\n\t\tif ( predicate.call( thisArg, v, i, this ) ) {\n\t\t\treturn v;\n\t\t}\n\t}\n});\n\n/**\n* Returns the index of the last element in an array for which a predicate function returns a truthy value.\n*\n* @name findLastIndex\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {integer} index or -1\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var v = arr.findLastIndex( predicate );\n* // returns 2\n*/\nsetReadOnly( BooleanArray.prototype, 'findLastIndex', function findLastIndex( predicate, thisArg ) {\n\tvar buf;\n\tvar v;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = this._length-1; i >= 0; i-- ) {\n\t\tv = Boolean( buf[ i ] );\n\t\tif ( predicate.call( thisArg, v, i, this ) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n});\n\n/**\n* Returns an array element.\n*\n* @name get\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {NonNegativeInteger} idx - element index\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} must provide a nonnegative integer\n* @returns {(boolean|void)} array element\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var v = arr.get( 0 );\n* // returns false\n*\n* arr.set( [ true, false ], 0 );\n*\n* v = arr.get( 0 );\n* // returns true\n*\n* v = arr.get( 100 );\n* // returns undefined\n*/\nsetReadOnly( BooleanArray.prototype, 'get', function get( idx ) {\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isNonNegativeInteger( idx ) ) {\n\t\tthrow new TypeError( format( 'null2K', idx ) );\n\t}\n\tif ( idx >= this._length ) {\n\t\treturn;\n\t}\n\treturn Boolean( this._buffer[ idx ] );\n});\n\n/**\n* Number of array elements.\n*\n* @name length\n* @memberof BooleanArray.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var len = arr.length;\n* // returns 10\n*/\nsetReadOnlyAccessor( BooleanArray.prototype, 'length', function get() {\n\treturn this._length;\n});\n\n/**\n* Returns a new array with each element being the result of a provided callback function.\n*\n* @name map\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} fcn - callback function\n* @param {*} [thisArg] - callback function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {BooleanArray} new boolean array\n*\n* @example\n* function invert( v ) {\n*     return !v;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var out = arr.map( invert );\n* // returns <BooleanArray>\n*\n* var z = out.get( 0 );\n* // returns false\n*\n* z = out.get( 1 );\n* // returns true\n*\n* z = out.get( 2 );\n* // returns false\n*/\nsetReadOnly( BooleanArray.prototype, 'map', function map( fcn, thisArg ) {\n\tvar outbuf;\n\tvar out;\n\tvar buf;\n\tvar i;\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( fcn ) ) {\n\t\tthrow new TypeError( format('null3c'), fcn );\n\t}\n\tbuf = this._buffer;\n\tout = new this.constructor( this._length );\n\toutbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\toutbuf[ i ] = Boolean( fcn.call( thisArg, Boolean( buf[ i ] ), i, this ) );\n\t}\n\treturn out;\n});\n\n/**\n* Reverses an array in-place.\n*\n* @name reverse\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @throws {TypeError} `this` must be a boolean array\n* @returns {BooleanArray} reversed array\n*\n* @example\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( false, 2 );\n*\n* var out = arr.reverse();\n* // returns <BooleanArray>\n*\n* var v = out.get( 0 );\n* // returns false\n*\n* v = out.get( 1 );\n* // returns false\n*\n* v = out.get( 2 );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'reverse', function reverse() {\n\tvar buf;\n\tvar tmp;\n\tvar len;\n\tvar N;\n\tvar i;\n\tvar j;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tbuf = this._buffer;\n\tlen = this._length;\n\tN = floor( len / 2 );\n\tfor ( i = 0; i < N; i++ ) {\n\t\tj = len - i - 1;\n\t\ttmp = buf[ i ];\n\t\tbuf[ i ] = buf[ j ];\n\t\tbuf[ j ] = tmp;\n\t}\n\treturn this;\n});\n\n/**\n* Sets an array element.\n*\n* ## Notes\n*\n* -   When provided a typed array, we must check whether the source array shares the same buffer as the target array and whether the underlying memory overlaps. In particular, we are concerned with the following scenario:\n*\n*     ```text\n*     buf:                ---------------------\n*     src: ---------------------\n*     ```\n*\n*     In the above, as we copy values from `src`, we will overwrite values in the `src` view, resulting in duplicated values copied into the end of `buf`, which is not intended. Hence, to avoid overwriting source values, we must **copy** source values to a temporary array.\n*\n*     In the other overlapping scenario,\n*\n*     ```text\n*     buf: ---------------------\n*     src:                ---------------------\n*     ```\n*\n*     by the time we begin copying into the overlapping region, we are copying from the end of `src`, a non-overlapping region, which means we don't run the risk of copying copied values, rather than the original `src` values, as intended.\n*\n* @name set\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {(Collection|BooleanArray|*)} value - value(s)\n* @param {NonNegativeInteger} [i=0] - element index at which to start writing values\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} index argument must be a nonnegative integer\n* @throws {RangeError} index argument is out-of-bounds\n* @throws {RangeError} target array lacks sufficient storage to accommodate source values\n* @returns {void}\n*\n* @example\n* var arr = new BooleanArray( 10 );\n*\n* var v = arr.get( 0 );\n* // returns false\n*\n* arr.set( [ true, false ], 0 );\n*\n* v = arr.get( 0 );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'set', function set( value ) {\n\tvar sbuf;\n\tvar idx;\n\tvar buf;\n\tvar tmp;\n\tvar N;\n\tvar i;\n\tvar j;\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tbuf = this._buffer;\n\tif ( arguments.length > 1 ) {\n\t\tidx = arguments[ 1 ];\n\t\tif ( !isNonNegativeInteger( idx ) ) {\n\t\t\tthrow new TypeError( format( 'null2L', idx ) );\n\t\t}\n\t} else {\n\t\tidx = 0;\n\t}\n\tif ( isCollection( value ) ) {\n\t\tN = value.length;\n\t\tif ( idx+N > this._length ) {\n\t\t\tthrow new RangeError( format('null03') );\n\t\t}\n\t\tif ( isBooleanArray( value ) ) {\n\t\t\tsbuf = value._buffer; // eslint-disable-line no-underscore-dangle\n\t\t} else {\n\t\t\tsbuf = value;\n\t\t}\n\t\t// Check for overlapping memory...\n\t\tj = buf.byteOffset + (idx*BYTES_PER_ELEMENT);\n\t\tif (\n\t\t\tsbuf.buffer === buf.buffer &&\n\t\t\t(\n\t\t\t\tsbuf.byteOffset < j &&\n\t\t\t\tsbuf.byteOffset+sbuf.byteLength > j\n\t\t\t)\n\t\t) {\n\t\t\t// We need to copy source values...\n\t\t\ttmp = new Uint8Array( sbuf.length );\n\t\t\tfor ( i = 0; i < sbuf.length; i++ ) {\n\t\t\t\ttmp[ i ] = sbuf[ i ]; // TODO: handle accessor arrays\n\t\t\t}\n\t\t\tsbuf = tmp;\n\t\t}\n\t\tfor ( i = 0; i < N; idx++, i++ ) {\n\t\t\tbuf[ idx ] = ( sbuf[ i ] ) ? 1 : 0;\n\t\t}\n\t\treturn;\n\t}\n\tif ( idx >= this._length ) {\n\t\tthrow new RangeError( format( 'null2M', idx ) );\n\t}\n\tbuf[ idx ] = ( value ) ? 1 : 0;\n});\n\n/**\n* Tests whether at least one element in an array passes a test implemented by a predicate function.\n*\n* @name some\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} predicate - predicate function\n* @param {*} [thisArg] - predicate function execution context\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {boolean} boolean indicating whether at least one element passes a test\n*\n* @example\n* function predicate( v ) {\n*     return v === true;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( false, 0 );\n* arr.set( true, 1 );\n* arr.set( false, 2 );\n*\n* var bool = arr.some( predicate );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'some', function some( predicate, thisArg ) {\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tif ( !isFunction( predicate ) ) {\n\t\tthrow new TypeError( format( 'null3c', predicate ) );\n\t}\n\tbuf = this._buffer;\n\tfor ( i = 0; i < this._length; i++ ) {\n\t\tif ( predicate.call( thisArg, Boolean( buf[ i ] ), i, this ) ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n});\n\n/**\n* Sorts an array in-place.\n*\n* @name sort\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} [compareFcn] - comparison function\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {BooleanArray} sorted array\n*\n* @example\n* function compare( a, b ) {\n*    if ( a === false ) {\n*        if ( b === false ) {\n*            return 0;\n*        }\n*        return 1;\n*    }\n*    if ( b === true ) {\n*        return 0;\n*    }\n*    return -1;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* arr.sort( compare );\n*\n* var v = arr.get( 0 );\n* // returns true\n*\n* v = arr.get( 1 );\n* // returns true\n*\n* v = arr.get( 2 );\n* // returns false\n*/\nsetReadOnly( BooleanArray.prototype, 'sort', function sort( compareFcn ) {\n\tvar buf;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tbuf = this._buffer;\n\tif ( arguments.length === 0 ) {\n\t\tbuf.sort();\n\t\treturn this;\n\t}\n\tif ( !isFunction( compareFcn ) ) {\n\t\tthrow new TypeError( format( 'null3c', compareFcn ) );\n\t}\n\tbuf.sort( compare );\n\treturn this;\n\n\t/**\n\t* Comparison function for sorting.\n\t*\n\t* @private\n\t* @param {boolean} a - first boolean value for comparison\n\t* @param {boolean} b - second boolean value for comparison\n\t* @returns {number} comparison result\n\t*/\n\tfunction compare( a, b ) {\n\t\treturn compareFcn( Boolean( a ), Boolean( b ) );\n\t}\n});\n\n/**\n* Returns a new typed array containing the elements in reversed order.\n*\n* @name toReversed\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @throws {TypeError} `this` must be a boolean array\n* @returns {BooleanArray} reversed array\n*\n* @example\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( false, 2 );\n*\n* var out = arr.toReversed();\n* // returns <BooleanArray>\n*\n* var v = out.get( 0 );\n* // returns false\n*\n* v = out.get( 1 );\n* // returns false\n*\n* v = out.get( 2 );\n* // returns true\n*/\nsetReadOnly( BooleanArray.prototype, 'toReversed', function toReversed() {\n\tvar outbuf;\n\tvar out;\n\tvar len;\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tlen = this._length;\n\tout = new this.constructor( len );\n\tbuf = this._buffer;\n\toutbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\tfor ( i = 0; i < len; i++ ) {\n\t\toutbuf[ i ] = buf[ len - i - 1 ];\n\t}\n\treturn out;\n});\n\n/**\n* Returns a new typed array containing the elements in sorted order.\n*\n* @name toSorted\n* @memberof BooleanArray.prototype\n* @type {Function}\n* @param {Function} [compareFcn] - comparison function\n* @throws {TypeError} `this` must be a boolean array\n* @throws {TypeError} first argument must be a function\n* @returns {BooleanArray} sorted array\n*\n* @example\n* function compare( a, b ) {\n*    if ( a === false ) {\n*        if ( b === false ) {\n*            return 0;\n*        }\n*        return 1;\n*    }\n*    if ( b === true ) {\n*        return 0;\n*    }\n*    return -1;\n* }\n*\n* var arr = new BooleanArray( 3 );\n*\n* arr.set( true, 0 );\n* arr.set( false, 1 );\n* arr.set( true, 2 );\n*\n* var out = arr.sort( compare );\n* // returns <BooleanArray>\n*\n* var v = out.get( 0 );\n* // returns true\n*\n* v = out.get( 1 );\n* // returns true\n*\n* v = out.get( 2 );\n* // returns false\n*/\nsetReadOnly( BooleanArray.prototype, 'toSorted', function toSorted( compareFcn ) {\n\tvar outbuf;\n\tvar out;\n\tvar len;\n\tvar buf;\n\tvar i;\n\n\tif ( !isBooleanArray( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a boolean array.' );\n\t}\n\tlen = this._length;\n\tout = new this.constructor( len );\n\tbuf = this._buffer;\n\toutbuf = out._buffer; // eslint-disable-line no-underscore-dangle\n\tfor ( i = 0; i < len; i++ ) {\n\t\toutbuf[ i ] = buf[ i ];\n\t}\n\tif ( arguments.length === 0 ) {\n\t\toutbuf.sort();\n\t\treturn out;\n\t}\n\tif ( !isFunction( compareFcn ) ) {\n\t\tthrow new TypeError( format( 'null3c', compareFcn ) );\n\t}\n\toutbuf.sort( compare );\n\treturn out;\n\n\t/**\n\t* Comparison function for sorting.\n\t*\n\t* @private\n\t* @param {boolean} a - first boolean value for comparison\n\t* @param {boolean} b - second boolean value for comparison\n\t* @returns {number} comparison result\n\t*/\n\tfunction compare( a, b ) {\n\t\treturn compareFcn( Boolean( a ), Boolean( b ) );\n\t}\n});\n\n\n// EXPORTS //\n\nexport default BooleanArray;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Boolean from '@stdlib/boolean-ctor';\n\n\n// MAIN //\n\n/**\n* Fills an output array with \"boolean\" values.\n*\n* @private\n* @param {Uint8Array} buf - output array\n* @param {Array} arr - input array\n* @returns {Uint8Array} output array\n*/\nfunction fromArray( buf, arr ) {\n\tvar len;\n\tvar i;\n\n\tlen = arr.length;\n\tfor ( i = 0; i < len; i++ ) {\n\t\tbuf[ i ] = Boolean( arr[ i ] );\n\t}\n\treturn buf;\n}\n\n\n// EXPORTS //\n\nexport default fromArray;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Boolean from '@stdlib/boolean-ctor';\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @param {Function} clbk - callback to invoke for each iterated value\n* @param {*} thisArg - invocation context\n* @returns {Array} output array\n*/\nfunction fromIteratorMap( it, clbk, thisArg ) {\n\tvar out;\n\tvar v;\n\tvar i;\n\n\tout = [];\n\ti = -1;\n\twhile ( true ) {\n\t\tv = it.next();\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t\ti += 1;\n\t\tout.push( Boolean( clbk.call( thisArg, v.value, i ) ) );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default fromIteratorMap;\n"],"names":["fromIterator","it","out","v","next","done","push","Boolean","value","BYTES_PER_ELEMENT","Uint8Array","HAS_ITERATOR_SYMBOL","hasIteratorSymbolSupport","isBooleanArray","constructor","name","isBooleanArrayConstructor","BooleanArray","byteOffset","nargs","buf","len","arg","arguments","length","this","isNonNegativeInteger","isCollection","arr","i","fromArray","isArrayBuffer","isObject","TypeError","format","isFunction","ITERATOR_SYMBOL","byteLength","RangeError","setReadOnly","src","thisArg","clbk","tmp","get","set","accessorGetter","getter","_buffer","call","fromIteratorMap","args","setReadOnlyAccessor","prototype","buffer","predicate","_length","idx","fcn","outbuf","N","j","floor","sbuf","compareFcn","sort","a","b"],"mappings":";;s9CAkCA,SAASA,EAAcC,GACtB,IAAIC,EACAC,EAGJ,IADAD,EAAM,KAELC,EAAIF,EAAGG,QACAC,MAGPH,EAAII,KAAMC,EAASJ,EAAEK,QAEtB,OAAON,CACR,CCDA,IAAAO,EAAAC,EAAAD,kBACAE,EAAAC,IAYA,SAAAC,EAAAL,GACA,MACA,iBAAAA,GACA,OAAAA,GACA,iBAAAA,EAAAM,YAAAC,MACAP,EAAAC,oBAAAA,CAEA,CASA,SAAAO,EAAAR,GACA,OAAAA,IAAAS,CACA,CAoEA,SAAAA,IACA,IAAAC,EACAC,EACAC,EACAC,EACAC,EAGA,GADAH,EAAAI,UAAAC,SACAC,gBAAAR,GACA,OAAA,IAAAE,EACA,IAAAF,EAEA,IAAAE,EACA,IAAAF,EAAAM,UAAA,IAEA,IAAAJ,EACA,IAAAF,EAAAM,UAAA,GAAAA,UAAA,IAEA,IAAAN,EAAAM,UAAA,GAAAA,UAAA,GAAAA,UAAA,IAGA,GAAA,IAAAJ,EACAC,EAAA,IAAAV,EAAA,QACA,GAAA,IAAAS,EAEA,GAAAO,EADAJ,EAAAC,UAAA,IAEAH,EAAA,IAAAV,EAAAY,QACA,GAAAK,EAAAL,GACAF,EC1IA,SAAoBA,EAAKQ,GACxB,IAAIP,EACAQ,EAGJ,IADAR,EAAMO,EAAIJ,OACJK,EAAI,EAAGA,EAAIR,EAAKQ,IACrBT,EAAKS,GAAMtB,EAASqB,EAAKC,IAE1B,OAAOT,CACR,CDiIAU,CAAA,IAAApB,EAAAY,EAAAE,QAAAF,QACA,GAAAS,EAAAT,GACAF,EAAA,IAAAV,EAAAY,OACA,KAAAU,EAAAV,GAaA,MAAA,IAAAW,UAAAC,EAAA,SAAAZ,IAZA,IAAA,IAAAX,EACA,MAAA,IAAAsB,UAAAC,EAAA,SAAAZ,IAEA,IAAAa,EAAAb,EAAAc,IACA,MAAA,IAAAH,UAAAC,EAAA,SAAAZ,IAGA,GADAF,EAAAE,EAAAc,MACAD,EAAAf,EAAAhB,MACA,MAAA,IAAA6B,UAAAC,EAAA,SAAAZ,IAEAF,EAAA,IAAAV,EAAAV,EAAAoB,GAGA,KACA,CAEA,IAAAW,EADAX,EAAAG,UAAA,IAEA,MAAA,IAAAU,UAAAC,EAAA,SAAAd,IAGA,IAAAM,EADAR,EAAAK,UAAA,IAEA,MAAA,IAAAU,UAAAC,EAAA,SAAAhB,IAEA,GAAA,IAAAC,EACAC,EAAA,IAAAV,EAAAU,EAAAF,OACA,CAEA,IAAAQ,EADAL,EAAAE,UAAA,IAEA,MAAA,IAAAU,UAAAC,EAAA,SAAAb,IAEA,GAAAA,EAAAZ,EAAAW,EAAAiB,WAAAnB,EACA,MAAA,IAAAoB,WAAAJ,EAAA,SAAAb,EAAAZ,IAEAW,EAAA,IAAAV,EAAAU,EAAAF,EAAAG,EACA,CACA,CAIA,OAHAkB,EAAAd,KAAA,UAAAL,GACAmB,EAAAd,KAAA,UAAAL,EAAAI,QAEAC,IACA,CAeAc,EAAAtB,EAAA,oBAAAR,GAeA8B,EAAAtB,EAAA,OAAA,gBAmCAsB,EAAAtB,EAAA,QAAA,SAAAuB,GACA,IAAAC,EACAtB,EACAuB,EACAxC,EACAkB,EACAuB,EACAC,EACAvB,EACAQ,EACA,IAAAM,EAAAV,MACA,MAAA,IAAAQ,UAAAC,EAAA,WAEA,IAAAlB,EAAAS,MACA,MAAA,IAAAQ,UAAA,sDAGA,IADAd,EAAAI,UAAAC,QACA,EAAA,CAEA,IAAAW,EADAO,EAAAnB,UAAA,IAEA,MAAA,IAAAU,UAAAC,EAAA,SAAAQ,IAEAvB,EAAA,IACAsB,EAAAlB,UAAA,GAEA,CACA,GAAAI,EAAAa,GAAA,CACA,GAAAE,EAAA,CASA,IARArB,EAAAmB,EAAAhB,OAEAoB,EADAJ,EAAAI,KAAAJ,EAAAK,IACAC,EAAA,WAEAC,EAAA,WAGA3B,GADAlB,EAAA,IAAAuB,KAAAJ,IACA2B,QACAnB,EAAA,EAAAA,EAAAR,EAAAQ,IACAT,EAAAS,GAAAtB,EAAAmC,EAAAO,KAAAR,EAAAG,EAAAJ,EAAAX,GAAAA,IAEA,OAAA3B,CACA,CACA,OAAA,IAAAuB,KAAAe,EACA,CACA,GAAAR,EAAAQ,IAAA7B,GAAAwB,EAAAK,EAAAJ,IAAA,CAEA,GADAhB,EAAAoB,EAAAJ,MACAD,EAAAf,EAAAhB,MACA,MAAA,IAAA6B,UAAAC,EAAA,SAAAM,IAUA,IAPAG,EADAD,EEtSA,SAA0BzC,EAAIyC,EAAMD,GACnC,IAAIvC,EACAC,EACA0B,EAIJ,IAFA3B,EAAM,GACN2B,GAAK,IAEJ1B,EAAIF,EAAGG,QACAC,MAGPwB,GAAK,EACL3B,EAAII,KAAMC,EAASmC,EAAKO,KAAMR,EAAStC,EAAEK,MAAOqB,KAEjD,OAAO3B,CACR,CFuRAgD,CAAA9B,EAAAsB,EAAAD,GAEAzC,EAAAoB,GAIAA,GADAlB,EAAA,IAAAuB,KADAJ,EAAAsB,EAAAnB,SAEAwB,QACAnB,EAAA,EAAAA,EAAAR,EAAAQ,IACAT,EAAAS,GAAAc,EAAAd,GAEA,OAAA3B,CACA,CACA,MAAA,IAAA+B,UAAAC,EAAA,SAAAM,GACA,IAoBAD,EAAAtB,EAAA,MAAA,WACA,IAAAkC,EACAtB,EACA,IAAAM,EAAAV,MACA,MAAA,IAAAQ,UAAAC,EAAA,WAEA,IAAAlB,EAAAS,MACA,MAAA,IAAAQ,UAAA,sDAGA,IADAkB,EAAA,GACAtB,EAAA,EAAAA,EAAAN,UAAAC,OAAAK,IACAsB,EAAA7C,KAAAiB,UAAAM,IAEA,OAAA,IAAAJ,KAAA0B,EACA,IAgBAC,EAAAnC,EAAAoC,UAAA,UAAA,WACA,OAAA5B,KAAAuB,QAAAM,MACA,IAgBAF,EAAAnC,EAAAoC,UAAA,cAAA,WACA,OAAA5B,KAAAuB,QAAAX,UACA,IAgBAe,EAAAnC,EAAAoC,UAAA,cAAA,WACA,OAAA5B,KAAAuB,QAAA9B,UACA,IAiBAqB,EAAAtB,EAAAoC,UAAA,oBAAApC,EAAAR,mBA4BA8B,EAAAtB,EAAAoC,UAAA,SAAA,SAAAE,EAAAd,GACA,IAAArB,EACAS,EAEA,IAAAhB,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAEA,IAAAE,EAAAoB,GACA,MAAA,IAAAtB,UAAAC,EAAA,SAAAqB,IAGA,IADAnC,EAAAK,KAAAuB,QACAnB,EAAA,EAAAA,EAAAJ,KAAA+B,QAAA3B,IACA,IAAA0B,EAAAN,KAAAR,EAAAlC,EAAAa,EAAAS,IAAAA,EAAAJ,MACA,OAAA,EAGA,OAAA,CACA,IA4BAc,EAAAtB,EAAAoC,UAAA,QAAA,SAAAE,EAAAd,GACA,IAAArB,EACAjB,EACA0B,EAEA,IAAAhB,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAEA,IAAAE,EAAAoB,GACA,MAAA,IAAAtB,UAAAC,EAAA,SAAAqB,IAGA,IADAnC,EAAAK,KAAAuB,QACAnB,EAAA,EAAAA,EAAAJ,KAAA+B,QAAA3B,IAEA,GADA1B,EAAAI,EAAAa,EAAAS,IACA0B,EAAAN,KAAAR,EAAAtC,EAAA0B,EAAAJ,MACA,OAAAtB,CAGA,IA4BAoC,EAAAtB,EAAAoC,UAAA,aAAA,SAAAE,EAAAd,GACA,IAAArB,EACAjB,EACA0B,EAEA,IAAAhB,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAEA,IAAAE,EAAAoB,GACA,MAAA,IAAAtB,UAAAC,EAAA,SAAAqB,IAGA,IADAnC,EAAAK,KAAAuB,QACAnB,EAAA,EAAAA,EAAAJ,KAAA+B,QAAA3B,IAEA,GADA1B,EAAAI,EAAAa,EAAAS,IACA0B,EAAAN,KAAAR,EAAAtC,EAAA0B,EAAAJ,MACA,OAAAI,EAGA,OAAA,CACA,IA4BAU,EAAAtB,EAAAoC,UAAA,YAAA,SAAAE,EAAAd,GACA,IAAArB,EACAjB,EACA0B,EAEA,IAAAhB,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAEA,IAAAE,EAAAoB,GACA,MAAA,IAAAtB,UAAAC,EAAA,SAAAqB,IAGA,IADAnC,EAAAK,KAAAuB,QACAnB,EAAAJ,KAAA+B,QAAA,EAAA3B,GAAA,EAAAA,IAEA,GADA1B,EAAAI,EAAAa,EAAAS,IACA0B,EAAAN,KAAAR,EAAAtC,EAAA0B,EAAAJ,MACA,OAAAtB,CAGA,IA4BAoC,EAAAtB,EAAAoC,UAAA,iBAAA,SAAAE,EAAAd,GACA,IAAArB,EACAjB,EACA0B,EAEA,IAAAhB,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAEA,IAAAE,EAAAoB,GACA,MAAA,IAAAtB,UAAAC,EAAA,SAAAqB,IAGA,IADAnC,EAAAK,KAAAuB,QACAnB,EAAAJ,KAAA+B,QAAA,EAAA3B,GAAA,EAAAA,IAEA,GADA1B,EAAAI,EAAAa,EAAAS,IACA0B,EAAAN,KAAAR,EAAAtC,EAAA0B,EAAAJ,MACA,OAAAI,EAGA,OAAA,CACA,IA2BAU,EAAAtB,EAAAoC,UAAA,OAAA,SAAAI,GACA,IAAA5C,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAEA,IAAAP,EAAA+B,GACA,MAAA,IAAAxB,UAAAC,EAAA,SAAAuB,IAEA,KAAAA,GAAAhC,KAAA+B,SAGA,OAAAjD,EAAAkB,KAAAuB,QAAAS,GACA,IAgBAL,EAAAnC,EAAAoC,UAAA,UAAA,WACA,OAAA5B,KAAA+B,OACA,IAqCAjB,EAAAtB,EAAAoC,UAAA,OAAA,SAAAK,EAAAjB,GACA,IAAAkB,EACAzD,EACAkB,EACAS,EACA,IAAAhB,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAEA,IAAAE,EAAAuB,GACA,MAAA,IAAAzB,UAAAC,EAAA,UAAAwB,GAKA,IAHAtC,EAAAK,KAAAuB,QAEAW,GADAzD,EAAA,IAAAuB,KAAAX,YAAAW,KAAA+B,UACAR,QACAnB,EAAA,EAAAA,EAAAJ,KAAA+B,QAAA3B,IACA8B,EAAA9B,GAAAtB,EAAAmD,EAAAT,KAAAR,EAAAlC,EAAAa,EAAAS,IAAAA,EAAAJ,OAEA,OAAAvB,CACA,IA8BAqC,EAAAtB,EAAAoC,UAAA,WAAA,WACA,IAAAjC,EACAuB,EACAtB,EACAuC,EACA/B,EACAgC,EAEA,IAAAhD,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAKA,IAHAb,EAAAK,KAAAuB,QACA3B,EAAAI,KAAA+B,QACAI,EAAAE,EAAAzC,EAAA,GACAQ,EAAA,EAAAA,EAAA+B,EAAA/B,IACAgC,EAAAxC,EAAAQ,EAAA,EACAc,EAAAvB,EAAAS,GACAT,EAAAS,GAAAT,EAAAyC,GACAzC,EAAAyC,GAAAlB,EAEA,OAAAlB,IACA,IA+CAc,EAAAtB,EAAAoC,UAAA,OAAA,SAAA7C,GACA,IAAAuD,EACAN,EACArC,EACAuB,EACAiB,EACA/B,EACAgC,EACA,IAAAhD,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAGA,GADAb,EAAAK,KAAAuB,QACAzB,UAAAC,OAAA,GAEA,IAAAE,EADA+B,EAAAlC,UAAA,IAEA,MAAA,IAAAU,UAAAC,EAAA,SAAAuB,SAGAA,EAAA,EAEA,GAAA9B,EAAAnB,GAAA,CAEA,GAAAiD,GADAG,EAAApD,EAAAgB,QACAC,KAAA+B,QACA,MAAA,IAAAlB,WAAAJ,EAAA,WASA,GANA6B,EADAlD,EAAAL,GACAA,EAAAwC,QAEAxC,EAGAqD,EAAAzC,EAAAF,WAAAuC,EAAAhD,EAEAsD,EAAAT,SAAAlC,EAAAkC,QAEAS,EAAA7C,WAAA2C,GACAE,EAAA7C,WAAA6C,EAAA1B,WAAAwB,EAEA,CAGA,IADAlB,EAAA,IAAAjC,EAAAqD,EAAAvC,QACAK,EAAA,EAAAA,EAAAkC,EAAAvC,OAAAK,IACAc,EAAAd,GAAAkC,EAAAlC,GAEAkC,EAAApB,CACA,CACA,IAAAd,EAAA,EAAAA,EAAA+B,EAAAH,IAAA5B,IACAT,EAAAqC,GAAAM,EAAAlC,GAAA,EAAA,CAGA,KA9BA,CA+BA,GAAA4B,GAAAhC,KAAA+B,QACA,MAAA,IAAAlB,WAAAJ,EAAA,SAAAuB,IAEArC,EAAAqC,GAAA,EAAA,EAAA,CAJA,CAKA,IA4BAlB,EAAAtB,EAAAoC,UAAA,QAAA,SAAAE,EAAAd,GACA,IAAArB,EACAS,EAEA,IAAAhB,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAEA,IAAAE,EAAAoB,GACA,MAAA,IAAAtB,UAAAC,EAAA,SAAAqB,IAGA,IADAnC,EAAAK,KAAAuB,QACAnB,EAAA,EAAAA,EAAAJ,KAAA+B,QAAA3B,IACA,GAAA0B,EAAAN,KAAAR,EAAAlC,EAAAa,EAAAS,IAAAA,EAAAJ,MACA,OAAA,EAGA,OAAA,CACA,IA4CAc,EAAAtB,EAAAoC,UAAA,QAAA,SAAAW,GACA,IAAA5C,EAEA,IAAAP,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAGA,GADAb,EAAAK,KAAAuB,QACA,IAAAzB,UAAAC,OAEA,OADAJ,EAAA6C,OACAxC,KAEA,IAAAU,EAAA6B,GACA,MAAA,IAAA/B,UAAAC,EAAA,SAAA8B,IAGA,OADA5C,EAAA6C,MAWA,SAAAC,EAAAC,GACA,OAAAH,EAAAzD,EAAA2D,GAAA3D,EAAA4D,GACA,IAZA1C,IAaA,IA8BAc,EAAAtB,EAAAoC,UAAA,cAAA,WACA,IAAAM,EACAzD,EACAmB,EACAD,EACAS,EAEA,IAAAhB,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAMA,IAJAZ,EAAAI,KAAA+B,QACAtD,EAAA,IAAAuB,KAAAX,YAAAO,GACAD,EAAAK,KAAAuB,QACAW,EAAAzD,EAAA8C,QACAnB,EAAA,EAAAA,EAAAR,EAAAQ,IACA8B,EAAA9B,GAAAT,EAAAC,EAAAQ,EAAA,GAEA,OAAA3B,CACA,IA6CAqC,EAAAtB,EAAAoC,UAAA,YAAA,SAAAW,GACA,IAAAL,EACAzD,EACAmB,EACAD,EACAS,EAEA,IAAAhB,EAAAY,MACA,MAAA,IAAAQ,UAAA,sDAMA,IAJAZ,EAAAI,KAAA+B,QACAtD,EAAA,IAAAuB,KAAAX,YAAAO,GACAD,EAAAK,KAAAuB,QACAW,EAAAzD,EAAA8C,QACAnB,EAAA,EAAAA,EAAAR,EAAAQ,IACA8B,EAAA9B,GAAAT,EAAAS,GAEA,GAAA,IAAAN,UAAAC,OAEA,OADAmC,EAAAM,OACA/D,EAEA,IAAAiC,EAAA6B,GACA,MAAA,IAAA/B,UAAAC,EAAA,SAAA8B,IAGA,OADAL,EAAAM,MAWA,SAAAC,EAAAC,GACA,OAAAH,EAAAzD,EAAA2D,GAAA3D,EAAA4D,GACA,IAZAjE,CAaA"}